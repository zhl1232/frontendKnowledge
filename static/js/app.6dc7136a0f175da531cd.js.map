{"version":3,"sources":["webpack:///./src/article/annualPlan.md","webpack:///./src/article/semantic1.md","webpack:///./src/article/type2.md","webpack:///./src/article/type1.md","webpack:///./src/App.vue?ed42","webpack:///./src/App.vue","webpack:///src/App.vue","webpack:///src/components/home.vue","webpack:///./src/components/home.vue?4cf0","webpack:///./src/components/home.vue","webpack:///./src/router/index.js","webpack:///./src/main.js","webpack:///external \"echarts\"","webpack:///./src/article/typex.md","webpack:///./src/article ^\\.\\/.*\\.md$","webpack:///./src/article/type3.md"],"names":["module","exports","selectortype_template_index_0_src_App","render","_h","this","$createElement","_c","_self","attrs","id","_v","staticRenderFns","src_App","__webpack_require__","normalizeComponent","name","ssrContext","home","data","title","dialogVisible","input","children","file","mounted","Chart","mark","computed","compiledMarkdown","marked_default","sanitize","methods","renderMD","a","Renderer","setOptions","renderer","gfm","tables","breaks","pedantic","smartLists","smartypants","highlight","code","lang","hljs","highlightAuto","value","myChart","$echarts","init","document","getElementById","that","on","params","$message","message","type","option","tooltip","trigger","triggerOn","series","top","left","bottom","right","symbolSize","label","normal","position","verticalAlign","align","fontSize","leaves","initialTreeDepth","expandAndCollapse","animationDuration","animationDurationUpdate","hideLoading","setOption","components_home","_vm","staticStyle","height","visible","width","center","update:visible","$event","domProps","innerHTML","_s","staticClass","slot","click","src_components_home","home_normalizeComponent","Vue","use","Router","router","routes","path","component","prototype","echarts","lib_button_default","lib_dialog_default","lib_message_default","config","productionTip","el","components","App","template","map","./annualPlan.md","./semantic1.md","./type1.md","./type2.md","./type3.md","./typex.md","webpackContext","req","webpackContextResolve","Error","keys","Object","resolve"],"mappings":"8DAAAA,EAAAC,QAAA,ipBCAAD,EAAAC,QAAA,0jGCAAD,EAAAC,QAAA,43VCAAD,EAAAC,QAAA,ipQCGeC,GADEC,OAFjB,WAA0B,IAAaC,EAAbC,KAAaC,eAA0BC,EAAvCF,KAAuCG,MAAAD,IAAAH,EAAwB,OAAAG,EAAA,OAAiBE,OAAOC,GAAA,SAAYH,EAAA,MAAnGF,KAAmGM,GAAA,+BAAnGN,KAAmGM,GAAA,KAAAJ,EAAA,oBAE5GK,oBCCjB,IAuBeC,EAvBUC,EAAQ,OAcjCC,ECRAC,KAAA,ODUEd,GATF,EAVA,SAAAe,GACEH,EAAQ,SAaV,KAEA,MAUgC,yCEHhCI,GACAC,KADA,WAEA,OACAC,MAAA,GACAC,eAAA,EACAC,MAAA,GAEAH,MACAH,KAAA,SACAO,WAEAP,KAAA,aACAO,WAEAP,KAAA,MACAO,WAEAP,KAAA,OACAO,WAEAP,KAAA,KACAO,WAEAP,KAAA,OACAQ,KAAA,UAGAR,KAAA,KACAQ,KAAA,UAGAR,KAAA,OACAQ,KAAA,YAKAR,KAAA,KACAO,WAEAP,KAAA,cAOAA,KAAA,SACAO,WACAP,KAAA,SACAA,KAAA,WACAA,KAAA,UACAA,KAAA,eAMAA,KAAA,KACAO,WAEAP,KAAA,OAIAA,KAAA,SAKAA,KAAA,KACAO,WAEAP,KAAA,QACAQ,KAAA,kBAOAR,KAAA,WACAO,WAEAP,KAAA,OACAO,WAEAP,KAAA,KACAO,WACAP,KAAA,UACAA,KAAA,WACAA,KAAA,OACAA,KAAA,UACAA,KAAA,OACAA,KAAA,OACAA,KAAA,SAIAA,KAAA,KACAO,WAAAP,KAAA,OAAAA,KAAA,WAGAA,KAAA,WAKAA,KAAA,MACAO,WAEAP,KAAA,KACAO,WAAAP,KAAA,UAAAA,KAAA,QAAAA,KAAA,SAGAA,KAAA,KACAO,WAEAP,KAAA,KACAO,WAAAP,KAAA,QAAAA,KAAA,WAGAA,KAAA,KACAO,WAAAP,KAAA,UAAAA,KAAA,WAGAA,KAAA,KACAO,WAAAP,KAAA,OAAAA,KAAA,iBASAA,KAAA,eACAO,WAEAP,KAAA,OACAO,WACAP,KAAA,OACAA,KAAA,WACAA,KAAA,UACAA,KAAA,eAIAA,KAAA,MACAO,WACAP,KAAA,QACAA,KAAA,UACAA,KAAA,OACAA,KAAA,eAMAA,KAAA,SACAO,WACAP,KAAA,OACAA,KAAA,QACAA,KAAA,SACAA,KAAA,SACAA,KAAA,gBAOAS,QA5KA,WA6KApB,KAAAqB,QACArB,KAAAsB,QAEAC,UACAC,iBAAA,WAEA,OAAAC,IAAAzB,KAAAiB,OAAAS,UAAA,MAGAC,SACAL,KADA,WAGA,IAAAM,EAAA,IAAAH,EAAAI,EAAAC,SACML,EAAAI,EAANE,YACAC,SAAAJ,EACAK,KAAA,EACAC,QAAA,EACAC,QAAA,EACAC,UAAA,EACAV,UAAA,EACAW,YAAA,EACAC,aAAA,EACAC,UAAA,SAAAC,EAAAC,GAGA,OAAAC,KAAAC,cAAAH,GAAAI,UAIAvB,MApBA,WAqBA,IAAAwB,EAAA7C,KAAA8C,SAAAC,KAAAC,SAAAC,eAAA,SACAC,EAAAlD,KACA6C,EAAAM,GAAA,iBAAAC,GACAA,EAAAtC,KAAAI,WAGAkC,EAAAtC,KAAAK,MAQA+B,EAAAnC,MAAAqC,EAAAzC,KAEAuC,EAAAjC,MAAAR,EAAA,OAAAA,CAAA,KAAA2C,EAAAtC,KAAAK,KAAA,OACA+B,EAAAlC,eAAA,GATAkC,EAAAG,UACAC,QAAA,WACAC,KAAA,eAWA,IAAAC,GAEAC,SACAC,QAAA,OACAC,UAAA,aAEAC,SAEAL,KAAA,OAEAzC,MAAAd,KAAAc,MAEA+C,IAAA,KACAC,KAAA,MACAC,OAAA,KACAC,MAAA,MAEAC,WAAA,GAEAC,OACAC,QACAC,SAAA,OACAC,cAAA,SACAC,MAAA,QACAC,SAAA,KAIAC,QACAN,OACAC,QACAC,SAAA,QACAC,cAAA,SACAC,MAAA,UAIAG,iBAAA,GACAC,mBAAA,EACAC,kBAAA,IACAC,wBAAA,OAIA/B,EAAAgC,cACAhC,EAAAiC,UAAAtB,MCjSeuB,GADEjF,OAFP,WAAgB,IAAAkF,EAAAhF,KAAaD,EAAAiF,EAAA/E,eAA0BC,EAAA8E,EAAA7E,MAAAD,IAAAH,EAAwB,OAAAG,EAAA,OAAAA,EAAA,OAA2B+E,aAAaC,OAAA,SAAiB9E,OAAQC,GAAA,UAAa2E,EAAA1E,GAAA,KAAAJ,EAAA,aAA8BE,OAAOW,MAAAiE,EAAAjE,MAAAoE,QAAAH,EAAAhE,cAAAoE,MAAA,MAAAC,OAAA,IAAwElC,IAAKmC,iBAAA,SAAAC,GAAkCP,EAAAhE,cAAAuE,MAA2BrF,EAAA,OAAYsF,UAAUC,UAAAT,EAAAU,GAAAV,EAAAxD,qBAA0CwD,EAAA1E,GAAA,KAAAJ,EAAA,QAAyByF,YAAA,gBAAAvF,OAAmCwF,KAAA,UAAgBA,KAAA,WAAe1F,EAAA,aAAkBiD,IAAI0C,MAAA,SAAAN,GAAyBP,EAAAhE,eAAA,MAA4BgE,EAAA1E,GAAA,SAAA0E,EAAA1E,GAAA,KAAAJ,EAAA,aAA8CE,OAAOmD,KAAA,WAAiBJ,IAAK0C,MAAA,SAAAN,GAAyBP,EAAAhE,eAAA,MAA4BgE,EAAA1E,GAAA,oBAE5pBC,oBCChC,IAuBeuF,EAvBUrF,EAAQ,OAcjBsF,CACdlF,EACAkE,GAT6B,EAV/B,SAAoBnE,GAClBH,EAAQ,SAaS,KAEU,MAUG,QCtBhCuF,UAAIC,IAAIC,KAEO,IAAAC,EAAA,IAAID,KACjBE,SAEIC,KAAM,IACN1F,KAAM,OACN2F,UAAWzF,qCCFjBmF,UAAIO,UAAUzD,SAAW0D,IACzBR,UAAIC,IAAJQ,EAAA5E,GACAmE,UAAIC,IAAJS,EAAA7E,GACAmE,UAAIO,UAAUlD,SAAdsD,EAAA9E,EAEAmE,UAAIY,OAAOC,eAAgB,EAG3B,IAAIb,WACFc,GAAI,OACJX,SACAY,YAAcC,OACdC,SAAU,+BCrBZtH,EAAAC,QAAA4G,iDCAA7G,EAAAC,QAAA,8wJCAA,IAAAsH,GACAC,kBAAA,OACAC,iBAAA,OACAC,aAAA,OACAC,aAAA,OACAC,aAAA,OACAC,aAAA,QAEA,SAAAC,EAAAC,GACA,OAAAjH,EAAAkH,EAAAD,IAEA,SAAAC,EAAAD,GACA,IAAArH,EAAA6G,EAAAQ,GACA,KAAArH,EAAA,GACA,UAAAuH,MAAA,uBAAAF,EAAA,MACA,OAAArH,EAEAoH,EAAAI,KAAA,WACA,OAAAC,OAAAD,KAAAX,IAEAO,EAAAM,QAAAJ,EACAhI,EAAAC,QAAA6H,EACAA,EAAApH,GAAA,2BCtBAV,EAAAC,QAAA","file":"static/js/app.6dc7136a0f175da531cd.js","sourcesContent":["module.exports = \"## 2019年度计划\\r\\n\\r\\n1万小时计划 (第184天/1095天)\\r\\n\\r\\n2018年计划结果基本超出预期，但超出预期的原因很大部分是因为环境。过程没做把控。所以之后的计划会做细化，以确保可以达到预期目标。\\r\\n\\r\\n2019年半年计划(第7天/180天)\\r\\n\\r\\n1. 重构前端知识架构 （第21天/91天）\\r\\n\\r\\n>   根据winter大神的 重学前端 为框架，穿插自己的理解学习和其它碎片知识。更新文章放在https://github.com/zhl1232/frontendKnowledge (文章每星期2篇,周结.现在第三篇写作中...8月10日前,知识架构涉及到的知识点全部填完)\\r\\n\\r\\n2. 每周至少四小时运动(周结,强制)\\r\\n\\r\\n> 挣钱再多,狗命要紧\\r\\n\\r\\n3. 算法.leetcode(17/210)\\r\\n\\r\\n> 暂定8月10日leetcode 210题,难度比例(7:2.5:0.5),基本每天一题,周结\\r\\n\\r\\n4. 英语(只做词汇量和阅读)\\r\\n\\r\\n> 每天20分钟,日结.\\r\\n\\r\\n5. 娱乐缓冲时间\\r\\n\\r\\n> 18年平均每天使用手机时间240分-300分.其中大概60分钟在看技术相关内容.每天玩手机时间压缩到180分,娱乐的正反馈转移到写文章和运动方面.时间多利用晚上和周末.\\r\\n\\r\\n# 砥砺前行\\r\\n> 2019年2月11日\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/annualPlan.md\n// module id = 38D4\n// module chunks = 1","module.exports = \"###### ARRON  2019年2月6日\\r\\n\\r\\n### 语义类标签是什么，使用它有什么好处？\\r\\n\\r\\n语义类标签在视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义。\\r\\n\\r\\n语义是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是纯文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，我们需要依靠语义标签代为表达。\\r\\n\\r\\n#### 正确使用语义标签可以带来很多好处\\r\\n- 语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有 CSS 的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。\\r\\n- 除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。\\r\\n\\r\\n### 作为自然语言延伸的语义类标签\\r\\n\\r\\n我们说话并没有唯一的标准措辞，语义标签的使用也是一样。\\r\\n\\r\\n一个好玩的ruby语义标签,如果没有这个标签的话,想实现ruby展示还比较麻烦。\\r\\n\\r\\n```\\r\\n<ruby>\\r\\n  你 <rt>sha</rt>\\r\\n  好 <rt>bi</rt>\\r\\n</ruby>\\r\\n```\\r\\n<ruby>\\r\\n  你 <rt>sha</rt>\\r\\n  好 <rt>bi</rt>\\r\\n</ruby>\\r\\n\\r\\n语义化标签对开发者的友好更多的表现为消除歧义，比如em标签表示重音，强调内容\\r\\n```\\r\\n// 这是一句不带任何强调的句子\\r\\n<p>Cats are cute animals.</p>\\r\\n\\r\\n// em 包围 Cats，强调猫是种可爱的动物，而不是狗或者其他动物\\r\\n<p><em>Cats</em> are cute animals.</p>\\r\\n\\r\\n// em 包围 are，代表句子所说是事实，来反驳那些说猫不可爱的人\\r\\n<p>Cats <em>are</em> cute animals.</p>\\r\\n\\r\\n// em 包围 cute，强调猫是一种可爱的动物，而不是有人说的刻薄、讨厌的动物\\r\\n<p>Cats are <em>cute</em> animals.</p>\\r\\n\\r\\n// 这里强调猫是动物，而不是植物\\r\\n<p>Cats are cute <em>animals</em>.</p>\\r\\n\\r\\n```\\r\\n\\r\\n而strong表示着重内容，代表内容的强烈的重要性、严重性或者紧急性。\\r\\n```\\r\\n// 章节序号不重要，章节的名字才重要\\r\\n<h1>Chapter 1: <strong>The Praxis</strong></h1>\\r\\n```\\r\\n\\r\\n><h1>Chapter 1: <strong>The Praxis</strong></h1>\\r\\n\\r\\n### 作为标题摘要的语义类标签\\r\\n\\r\\nh1-h6 是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用 hgroup 标签。\\r\\n```\\r\\n<h1>JavaScript 对象</h1>\\r\\n<h2> 我们需要模拟类吗？</h2>\\r\\n<p>balah balah</p>\\r\\n```\\r\\n```\\r\\n<hgroup>\\r\\n<h1>JavaScript 对象 </h1>\\r\\n<h2> 我们需要模拟类吗？</h2>\\r\\n</hgroup>\\r\\n<p>balah balah</p>\\r\\n```\\r\\n\\r\\n### 作为整体结构的语义类标签\\r\\n\\r\\n最后一个场景是，随着越来越多的浏览器推出“阅读模式”，以及各种非浏览器终端的出现，语义化的 HTML 适合机器阅读的特性变得越来越重要。\\r\\n\\r\\n应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。\\r\\n\\r\\n```\\r\\n<body>\\r\\n    <header>\\r\\n        <nav>\\r\\n            ……\\r\\n        </nav>\\r\\n    </header>\\r\\n    <aside>\\r\\n        <nav>\\r\\n            ……\\r\\n        </nav>\\r\\n    </aside>\\r\\n    <section>……</section>\\r\\n    <section>……</section>\\r\\n    <section>……</section>\\r\\n    <footer>\\r\\n        <address>……</address>\\r\\n    </footer>\\r\\n</body>\\r\\n```\\r\\n一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。\\r\\n```\\r\\n<body>\\r\\n    <header>……</header>\\r\\n    <article>\\r\\n        <header>……</header>\\r\\n        <section>……</section>\\r\\n        <section>……</section>\\r\\n        <section>……</section>\\r\\n        <footer>……</footer>\\r\\n    </article>\\r\\n    <article>\\r\\n        ……\\r\\n    </article>\\r\\n    <article>\\r\\n        ……\\r\\n    </article>\\r\\n    <footer>\\r\\n        <address></address>\\r\\n    </footer>\\r\\n</body>\\r\\n```\\r\\nbody 里面有自己的 header 和 footer，然后里面是竖篇的 article，每一个 article 里面都有自己的 header、section、footer。这是一个典型的多文章结构。\\r\\n\\r\\n最后 footer 中包含 address，这是个非常容易被误用的标签。address 并非像 date 一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address 明确地只关联到 article 和 body。\\r\\n\\r\\n### 总结\\r\\n\\r\\n至此，我们可以回答是否要语义化的问题：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。本篇文中，我们至少涉及了三个明确的场景：\\r\\n\\r\\n- 自然语言表达能力的补充；\\r\\n- 文章标题摘要；\\r\\n- 适合机器阅读的整体结构。\\r\\n\\r\\n\\r\\n参考链接\\r\\n\\r\\n[重学前端](https://time.geekbang.org/column/154)\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/semantic1.md\n// module id = 4DoG\n// module chunks = 1","module.exports = \"###### ARRON 2019 年 2 月 14 日\\r\\n\\r\\n语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合。\\r\\n\\r\\nObject（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。\\r\\n\\r\\n对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。\\r\\n\\r\\n### JavaScript 对象的特征\\r\\n\\r\\n不论我们使用什么样的编程语言，参考 Grandy Booch《面向对象分析与设计》总结来看，对象有如下几个特点。\\r\\n- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。\\r\\n- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。\\r\\n- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。\\r\\n\\r\\njavascript的对象唯一标识性\\r\\n```\\r\\n    var o1 = { a: 1 };\\r\\n    var o2 = { a: 1 };\\r\\n    console.log(o1 == o2); // false\\r\\n```\\r\\n关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们。\\r\\n\\r\\n在 JavaScript 中，将状态和行为统一抽象为“属性”。\\r\\n\\r\\n```\\r\\n    var o = { \\r\\n        d: 1,\\r\\n        f() {\\r\\n            console.log(this.d);\\r\\n        }    \\r\\n    };\\r\\n```\\r\\n对象o有d和f两个属性。\\r\\n\\r\\n<strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong>\\r\\n\\r\\n为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。\\r\\n\\r\\n### JavaScript 对象的两类属性\\r\\n\\r\\n对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。\\r\\n\\r\\n先来说第一类属性，数据属性。数据属性具有四个特征。\\r\\n\\r\\n- value：就是属性的值。\\r\\n- writeable：决定属性能否被赋值。\\r\\n- enumerble：决定 for in 能否枚举该属性。\\r\\n- configurable：决定该属性能否被删除或者改变特征值。\\r\\n\\r\\n第二类属性是访问器属性（getter/setter）属性,它也有四个属性。\\r\\n- getter：函数或 undefined，在取属性值时被调用。\\r\\n- getter：函数或 undefined，在设置属性值时被调用。\\r\\n- enumerble：决定 for in 能否枚举该属性。\\r\\n- configurable：决定该属性能否被删除或者改变特征值。\\r\\n\\r\\n访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值。\\r\\n\\r\\n```\\r\\nvar o = {\\r\\n  a: 7,\\r\\n  get b() { \\r\\n    return this.a + 1;\\r\\n  },\\r\\n  set c(x) {\\r\\n    this.a = x / 2\\r\\n  }\\r\\n};\\r\\n\\r\\nconsole.log(o.a); // 7\\r\\nconsole.log(o.b); // 8\\r\\no.c = 50;\\r\\nconsole.log(o.a); // 25\\r\\n```\\r\\n\\r\\n我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：\\r\\n```\\r\\n    var o = { a: 1 };\\r\\n    o.b = 2;\\r\\n    //a 和 b 皆为数据属性\\r\\n    Object.getOwnPropertyDescriptor(o,\\\"a\\\") // {value: 1, writable: true, enumerable: true, configurable: true}\\r\\n    Object.getOwnPropertyDescriptor(o,\\\"b\\\") // {value: 2, writable: true, enumerable: true, configurable: true}\\r\\n```\\r\\n如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：\\r\\n```\\r\\n    var o = { a: 1 };\\r\\n    Object.defineProperty(o, \\\"b\\\", {value: 2, writable: false, enumerable: false, configurable: true});\\r\\n    //a 和 b 都是数据属性，但特征值变化了\\r\\n    Object.getOwnPropertyDescriptor(o,\\\"a\\\"); // {value: 1, writable: true, enumerable: true, configurable: true}\\r\\n    Object.getOwnPropertyDescriptor(o,\\\"b\\\"); // {value: 2, writable: false, enumerable: false, configurable: true}\\r\\n    o.b = 3;\\r\\n    console.log(o.b); // 2\\r\\n```\\r\\n其实Object.freeze(obj)就是改变obj的writable,configurable为false\\r\\n\\r\\n\\r\\n实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。\\r\\n\\r\\n### 对象类型的存储\\r\\n\\r\\n在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。\\r\\n\\r\\n![image](asstes/images/type2.png)\\r\\n\\r\\n```\\r\\nconst a = {}\\r\\nlet b = a\\r\\na.c = 666\\r\\nconsole.log(b.c)  // 666\\r\\n```\\r\\n因为b和a指向同一个内存指针。同时也说明了const常量是针对内存指针的常量，只是内存指针地址不能改变。\\r\\n\\r\\n![image](asstes/images/type1.png)\\r\\n\\r\\n### 函数传值\\r\\n\\r\\n参数传值是指函数调用时，给函数传递配置或运行参数的行为，包括通过call、apply 进行传值。\\r\\n\\r\\n基本类型和引用类型在变量复制的时候存在区别：\\r\\n\\r\\n- 原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的 value 而已。\\r\\n- 引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。复制是不会产生新的堆内存消耗。\\r\\n\\r\\njavascript 中所有函数参数都是按值传递，都是把形参复制给实参，只是基本数据类型复制的是原始值，而引用类型复制的是堆内存的地址。\\r\\n\\r\\n#### 基本类型传值\\r\\n```\\r\\nlet a = 1\\r\\nfunction foo(x) {\\r\\n    x = 2\\r\\n    console.log(x)\\r\\n}\\r\\nfoo(a)  // 2\\r\\nconsole.log(a)  // 1\\r\\n```\\r\\n它们在全局上下文和foo的上下文中各自保存了值1，且相互之间互不影响，我们对 a、x的读写操作，操作的是他们各自的值。\\r\\n\\r\\n#### 引用类型传值\\r\\n\\r\\n```\\r\\nlet a = {\\r\\n    abc: 1\\r\\n}\\r\\nfunction foo(x) {\\r\\n    x.abc = 2\\r\\n    console.log(x.abc)\\r\\n}\\r\\nfoo(a)  // 2\\r\\nconsole.log(a.abc)   // 2\\r\\n```\\r\\n上面的代码很容易得出一个错误的结论，对象传值是按引用传递的。\\r\\n\\r\\n对象a的引用被传递到函数foo内部， 函数内部变量x指向全局变量a，从而实现了引用的传递，所以变量x和变量a读写的是同一个对象。\\r\\n\\r\\n如果是按引用传递那下面这个例子就懵比了：\\r\\n```\\r\\nlet a = {\\r\\n    abc: 1\\r\\n}\\r\\nfunction foo(x) {\\r\\n    console.log(x) // {abc: 1}\\r\\n    x = 2\\r\\n    console.log(x) // 2\\r\\n}\\r\\nfoo(a)\\r\\nconsole.log(a.abc) // 1\\r\\n```\\r\\n为什么会出现a、x在指向同一个对象后，对x赋值又没有改变原对象的值呢？\\r\\n\\r\\n因为这里对象传递给实参是按共享传递（call by sharing）的，根据引用类型变量复制的特点（上面描述过）：\\r\\n\\r\\nfoo 函数执行时， 形参 x 的值是传进去的对象 a 的内存地址引用，即在变量对象创建阶段x保存的是一个对象的堆内存地址。此时 a、x 都指向同一对象。 接着在函数的执行阶段，代码的第二行将原始数据类型 2 赋值给 x，导致 x 不再保存原先的堆内存地址转而保存一个原始值，再次访问 x 的时候是访问对 x 最后一次赋值的原始值。\\r\\n\\r\\n<strong>所以对 x 的赋值会改变上下文栈中标识符 x 保存的具体值</strong>\\r\\n\\r\\n```\\r\\nlet a = {\\r\\n    abc: 1\\r\\n}\\r\\nfunction foo(x) {\\r\\n    x.abc = 99\\r\\n    console.log(x) // {abc: 99}\\r\\n    x = 2\\r\\n    console.log(x) // 2\\r\\n}\\r\\nfoo(a)\\r\\nconsole.log(a) // {abc: 99}\\r\\n```\\r\\n在 foo 函数内部修改对象 x 的属性，会导致 x、a 指向的对象被修改，因为它们指向同一个堆地址。\\r\\n### 深浅拷贝\\r\\n\\r\\n上面说过引用类型变量拷贝的特点。但是实际业务中，有时需要将一个引用类型拷贝一份，并且两个对象的值还不会相互影响。\\r\\n\\r\\n这里存在两种情况：浅拷贝和深拷贝\\r\\n```\\r\\nlet object1 = {\\r\\n  a: 1,\\r\\n  obj: {\\r\\n    b: 'string'\\r\\n  }\\r\\n}\\r\\n```\\r\\n#### 浅拷贝\\r\\n\\r\\n浅拷贝也存在两种情况：\\r\\n- 直接拷贝对象，也就是拷贝引用，两个变量object1 和 object2 之间还是会相互影响。\\r\\n- 只是简单的拷贝对象的第一层属性，基本类型值不再相互影响，但是对其内部的引用类型值，拷贝的任然是是其引用，内部的引用类型值还是会相互影响。\\r\\n\\r\\n```\\r\\n// 最简单的浅拷贝\\r\\nlet object2 = object1;  // 两个对象指向一个引用地址，改一个另一个也会改变\\r\\n\\r\\nlet object2 = Object.assign({}, object1)\\r\\nobject1.a = 666\\r\\nobject1.obj.b = 'newString'\\r\\nconsole.log(object2.a)  // 666\\r\\nconsole.log(object2.obj.b)  // 'newString'\\r\\n```\\r\\n浅拷贝存在许多问题，需要我们注意：\\r\\n\\r\\n- 只能拷贝可枚举的属性。\\r\\n- 所生成的拷贝对象的原型与原对象的原型不同，拷贝对象只是 Object 的一个实例。\\r\\n- 原对象从它的原型继承的属性也会被拷贝到新对象中，就像是原对象的属性一样，无法区分。\\r\\n- 属性的描述符（descriptor）无法被复制，一个只读的属性在拷贝对象中可能会是可写的。\\r\\n- 如果属性是对象的话，原对象的属性会与拷贝对象的属性会指向一个对象，会彼此影响。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n\\tthis.name = 'parent'\\r\\n\\tthis.a = 1\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n\\tthis.name = 'child'\\r\\n\\tthis.b = 2\\r\\n}\\r\\n\\r\\nChild.prototype = new Parent()\\r\\n\\r\\nlet child1 = new Child()\\r\\nconsole.log(child1.a,child1.name); // 1 \\\"child\\\"\\r\\n\\r\\nconsole.log(Parent.prototype); \\r\\nconsole.log(Child.prototype); \\r\\n\\r\\nObject.defineProperty(child1, 'name', {writable: false, value: 'ARRON'})\\r\\n// 更改child1的描述符writable为false\\r\\nlet child2 = Object.assign({}, child1)\\r\\n\\r\\nconsole.log(Object.getOwnPropertyDescriptor(child2, 'name'));\\r\\n// Object{value: \\\"ARRON\\\", writable: true, enumerable: true, configurable: true}\\r\\n// 这里描述符的可赋值writable已经变成true\\r\\n\\r\\nchild1.name = 'newName'; // 严格模式下报错，普通模式下无效\\r\\nchild2.name = 'newName'; // 可以赋值\\r\\nconsole.log( child1.name ); //  ARRON\\r\\nconsole.log( child2.name ); // newName\\r\\n\\r\\n// 查看 child1 和 child2 的原型，我们也会发现它们的原型也是不同的\\r\\nconsole.log(child1.__proto__);  // Parent\\r\\nconsole.log(child2.__proto__);  // Object\\r\\n```\\r\\n#### 深拷贝\\r\\n\\r\\n深拷贝就是将对象的属性递归的拷贝到一个新的对象上，两个对象有不同的地址，不同的引用，也包括对象里的对象属性（如 object1 中的 obj 属性），两个变量之间完全独立。\\r\\n\\r\\n\\r\\n#### 一些常用的深浅拷贝方法\\r\\n\\r\\n##### 对象浅拷贝\\r\\n1. Object.assign()\\r\\n  \\r\\n```\\r\\nvar object2 = Object.assign({}, object1);\\r\\n```\\r\\n\\r\\n2. Object.getOwnPropertyNames 拷贝不可枚举的属性\\r\\n\\r\\nObject.getOwnPropertyNames() 返回由对象属性组成的一个数组，包括不可枚举的属性（除了使用 Symbol 的属性）。\\r\\n\\r\\n```\\r\\nfunction shallowCopyOwnProperties( source )  \\r\\n{\\r\\n    var target = {} ;\\r\\n    var keys = Object.getOwnPropertyNames( original ) ;\\r\\n    for ( var i = 0 ; i < keys.length ; i ++ ) {\\r\\n        target[ keys[ i ] ] = source[ keys[ i ] ] ;\\r\\n    }\\r\\n    return target ;\\r\\n}\\r\\n```\\r\\n\\r\\n3. Object.getPrototypeOf 和 Object.getOwnPropertyDescriptor 拷贝原型与描述符\\r\\n\\r\\n```\\r\\nfunction shallowCopy( source ) {\\r\\n    // 用 source 的原型创建一个对象\\r\\n    var target = Object.create( Object.getPrototypeOf( source )) ;\\r\\n    // 获取对象的所有属性\\r\\n    var keys = Object.getOwnPropertyNames( source ) ;\\r\\n    // 循环拷贝对象的所有属性\\r\\n    for ( var i = 0 ; i < keys.length ; i ++ ) {\\r\\n        // 用原属性的描述符创建新的属性\\r\\n        Object.defineProperty( target , keys[ i ] , Object.getOwnPropertyDescriptor( source , keys[ i ])) ;\\r\\n    }\\r\\n    return target ;\\r\\n}\\r\\n```\\r\\n\\r\\n##### 数组浅拷贝\\r\\n1. 直接复制或者遍历\\r\\n\\r\\n```\\r\\nvar array = [1, 'string', {a: 1,b: 2, obj: {c: 3}}];\\r\\n// 直接复制\\r\\nvar array1 = array;\\r\\n// 遍历直接复制\\r\\nvar array2 = [];\\r\\nfor(var key in array) {\\r\\n  array2[key] = array[key];\\r\\n}\\r\\n// 改变原数组元素\\r\\narray[1] = 'newString';\\r\\narray[2].c = 4;\\r\\n\\r\\nconsole.log(array1[1]); // newString\\r\\nconsole.log(array1[2].c); // 4\\r\\nconsole.log(array2[1]); // string\\r\\nconsole.log(array2[2].c); // 4\\r\\n```\\r\\n\\r\\n2. slice 和 concat \\r\\n   \\r\\n```\\r\\nvar array = [1, 'string', {a: 1,b: 2, obj: {c: 3}}];\\r\\n// slice()\\r\\nvar array1 = array.slice();\\r\\n// concat()\\r\\nvar array2 = array.concat();\\r\\n// 改变原数组元素\\r\\narray[1] = 'newString';\\r\\narray[2].c = 4;\\r\\n\\r\\nconsole.log(array1[1]); // string\\r\\nconsole.log(array1[2].c); // 4\\r\\nconsole.log(array2[1]); // string\\r\\nconsole.log(array2[2].c); // 4\\r\\n```\\r\\n\\r\\n##### 数组、对象的深拷贝\\r\\n1.  JSON.stringify 和 JSON.parse\\r\\n\\r\\n```\\r\\nvar obj = { a: 1, b: { c: 2 }};\\r\\n// 深拷贝\\r\\nvar newObj = JSON.parse(JSON.stringify(obj));\\r\\n// 改变原对象的属性\\r\\nobj.b.c = 20;\\r\\n\\r\\nconsole.log(obj); // { a: 1, b: { c: 20 } }\\r\\nconsole.log(newObj); // { a: 1, b: { c: 2 } }\\r\\n```\\r\\n\\r\\n优点是方便简洁，可以处理大多数业务需求。\\r\\n\\r\\n缺点是属性里有function、undefined和symbol的话会被忽略。并且如果值有循环引用对象的话会报错。\\r\\n2. MessageChannel\\r\\n如果你所需拷贝的对象含有内置类型并且不包含函数，可以用MessageChannel\\r\\n\\r\\n```\\r\\nfunction structuralClone(obj) {\\r\\n  return new Promise(resolve => {\\r\\n    const {port1, port2} = new MessageChannel();\\r\\n    port2.onmessage = ev => resolve(ev.data);\\r\\n    port1.postMessage(obj);\\r\\n  });\\r\\n}\\r\\n\\r\\nvar obj = {a: 1, b: {\\r\\n    c: b\\r\\n}}\\r\\n// 注意该方法是异步的\\r\\n// 可以处理 undefined 和循环引用对象\\r\\n(async () => {\\r\\n  const clone = await structuralClone(obj)\\r\\n})()\\r\\n```\\r\\n\\r\\n3. 其他\\r\\n\\r\\n手写或者用[ lodash 的深拷贝函数](https://lodash.com/docs##cloneDeep)\\r\\n### typeOf和instanceof\\r\\ntypeof可以判断除了null的所有原始类型\\r\\n\\r\\n```\\r\\ntypeof 1 // 'number'\\r\\ntypeof '1' // 'string'\\r\\ntypeof undefined // 'undefined'\\r\\ntypeof true // 'boolean'\\r\\ntypeof Symbol() // 'symbol'\\r\\n```\\r\\n\\r\\n但是不能判断对象，除了函数都会显示object\\r\\n\\r\\n```\\r\\ntypeof [] // 'object'\\r\\ntypeof {} // 'object'\\r\\ntypeof console.log // 'function'\\r\\n```\\r\\n\\r\\ninstanceof 内部是通过原型链来判断的\\r\\n\\r\\n```\\r\\nconst Person = function() {}\\r\\nconst p1 = new Person()\\r\\np1 instanceof Person // true\\r\\n\\r\\nvar str = 'hello world'\\r\\nstr instanceof String // false\\r\\n// 没有.运算符并不会做装箱转换\\r\\n\\r\\nvar str1 = new String('hello world')\\r\\nstr1 instanceof String // true\\r\\n```\\r\\n\\r\\n在上篇文章《基本类型》里说过，\\r\\n\\r\\n> 在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。\\r\\n\\r\\n> instanceof 的判定如果在两个环境下可能会出错。比如网页内嵌 iframe。\\r\\n\\r\\n而且 instanceof 的行为是可以自定义修改的。\\r\\n\\r\\n```\\r\\nclass PrimitiveString {\\r\\n  static [Symbol.hasInstance](x) {\\r\\n    return typeof x === 'string'\\r\\n  }\\r\\n}\\r\\nconsole.log('hello world' instanceof PrimitiveString) // true\\r\\n```\\r\\n\\r\\n参考链接\\r\\n\\r\\n[InterviewMap](https://yuchengkai.cn/docs/frontend/#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B)\\r\\n\\r\\n[javascript参数传值](https://segmentfault.com/a/1190000015105086)\\r\\n\\r\\n[深入理解 JavaScript 对象和数组拷贝](https://juejin.im/post/5a00226b5188255695390a74#heading-8)\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/type2.md\n// module id = Gotm\n// module chunks = 1","module.exports = \"###### ARRON 2019 年 2 月 7 日\\r\\n\\r\\nJS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。\\r\\n\\r\\n## 基本类型\\r\\n\\r\\n基本类型有六种： null，undefined，boolean，number，string，symbol\\r\\n\\r\\n首先我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。\\r\\n\\r\\nNumber、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。\\r\\n\\r\\nSymbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。\\r\\n\\r\\n原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString() 会抛出错误\\r\\n\\r\\n但为什么 '1'.toString() 是可以使用的。\\r\\n\\r\\n其实是 . 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。在该临时对象调用函数返回函数操作结果后，将该对象丢弃。\\r\\n\\r\\n### 装箱转换\\r\\n\\r\\n每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。\\r\\n\\r\\n前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。\\r\\n\\r\\n```\\r\\n    var symbolObject = (function(){ return this; }).call(Symbol(\\\"a\\\"));\\r\\n\\r\\n    console.log(typeof symbolObject); // object\\r\\n    console.log(symbolObject instanceof Symbol); // true\\r\\n    console.log(symbolObject.constructor   Symbol); // true\\r\\n```\\r\\n\\r\\n使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。\\r\\n\\r\\n```\\r\\n    var symbolObject = Object((Symbol(\\\"a\\\"));\\r\\n\\r\\n    console.log(typeof symbolObject); // object\\r\\n    console.log(symbolObject instanceof Symbol); // true\\r\\n    console.log(symbolObject.constructor   Symbol); // true\\r\\n\\r\\n```\\r\\n\\r\\n每一个装箱对象 console.dir 的时候，会发现有个 [[PrimitiveValue]] 标记，他会显示该对象内部指向的原始值。\\r\\n\\r\\n每一类对象（包括装箱对象）皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：\\r\\n\\r\\n```\\r\\n    var symbolObject = Object((Symbol(\\\"a\\\"));\\r\\n\\r\\n    console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]\\r\\n```\\r\\n\\r\\n在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。\\r\\n\\r\\ninstanceof 的判定如果在两个环境下可能会出错。比如网页内嵌 iframe。\\r\\n\\r\\n但需要注意的是，call 本身会产生装箱操作，所以判断类型的时候需要配合 typeof 来区分基本类型还是对象类型。\\r\\n\\r\\n### 拆箱转换\\r\\n\\r\\n在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。\\r\\n\\r\\n```\\r\\n[Symbol.toPrimitive](hint)\\r\\n```\\r\\n\\r\\n如果 hint 是 \\\"string\\\" 或 \\\"default\\\"，[@@toPrimitive]() 将会调用 toString。如果 toString 属性不存在，则调用 valueOf。如果 valueOf 也不存在，则抛出一个 TypeError。\\r\\n\\r\\n如果 hint 是 \\\"number\\\"，[@@toPrimitive]() 会首先尝试 valueOf，若失败再尝试 toString。\\r\\n\\r\\nnumber\\r\\n\\r\\n```\\r\\n    var o = {\\r\\n        valueOf : () => {console.log(\\\"valueOf\\\"); return {}},\\r\\n        toString : () => {console.log(\\\"toString\\\"); return {}}\\r\\n    }\\r\\n\\r\\n    o * 2\\r\\n    // valueOf\\r\\n    // toString\\r\\n    // TypeError\\r\\n```\\r\\n\\r\\nstring\\r\\n\\r\\n```\\r\\n    var o = {\\r\\n        valueOf : () => {console.log(\\\"valueOf\\\"); return {}},\\r\\n        toString : () => {console.log(\\\"toString\\\"); return {}}\\r\\n    }\\r\\n\\r\\n    o + \\\"\\\"\\r\\n    // toString\\r\\n    // valueOf\\r\\n    // TypeError\\r\\n```\\r\\n\\r\\n当在希望是字符串操作，也即发生对象到字符串的转换时，传入内部函数 ToPrimitive 的参数值即为 string，当在希望是数值操作，传入内部函数 ToPrimitive 的参数值即为 number，当在一些不确定需要将对象转换成什么基础类型的场景下，传入内部函数 ToPrimitive 的参数值即为 default：\\r\\n\\r\\n```\\r\\n\\tconst b = {\\r\\n\\t\\t\\t[Symbol.toPrimitive] (hint) {\\r\\n\\t\\t\\t\\t\\tconsole.log(`hint: ${hint}`);\\r\\n\\t\\t\\t\\t\\treturn {};\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\ttoString () {\\r\\n\\t\\t\\t\\t\\tconsole.log('toString');\\r\\n\\t\\t\\t\\t\\treturn 1;\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tvalueOf () {\\r\\n\\t\\t\\t\\t\\tconsole.log('valueOf');\\r\\n\\t\\t\\t\\t\\treturn 2;\\r\\n\\t\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\talert(b); // hint: string\\r\\n\\tb + ''; // hint: default\\r\\n\\tb + 500; // hint: default\\r\\n\\t+b; // hint: number\\r\\n\\tb * 1; // hint: number\\r\\n```\\r\\n\\r\\n在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。\\r\\n\\r\\n```\\r\\n    var o = {\\r\\n        valueOf : () => {console.log(\\\"valueOf\\\"); return {}},\\r\\n        toString : () => {console.log(\\\"toString\\\"); return {}}\\r\\n    }\\r\\n\\r\\n    o[Symbol.toPrimitive] = () => {console.log(\\\"toPrimitive\\\"); return \\\"hello\\\"}\\r\\n\\r\\n\\r\\n    console.log(o + \\\"\\\")\\r\\n    // toPrimitive\\r\\n    // hello\\r\\n```\\r\\n\\r\\n### null 和 undefined\\r\\n\\r\\nnull 代表赋值了，但内容为空，undefined 表示未定义。\\r\\n\\r\\n另外对于 null 来说。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\\r\\n\\r\\n一般建议用 void 0 代替 undefined ，因为在 ES5 之前 undefined 是一个变量，而并非是一个关键字，为了避免无意中被修改，建议用 void 0 代替 undefined\\r\\n\\r\\n```\\r\\n    let a\\r\\n    // 我们也可以这样判断 undefined\\r\\n    a  = undefined\\r\\n    // 但是 undefined 不是保留字，能够在低版本浏览器被赋值\\r\\n    let undefined = 1\\r\\n    // 这样判断就会出错\\r\\n    // 所以可以用下面的方式来判断，并且代码量更少\\r\\n    // 因为 void 后面随便跟上一个组成表达式\\r\\n    // 返回就是 undefined\\r\\n    a  = void 0\\r\\n```\\r\\n\\r\\n### Boolean\\r\\n\\r\\n```\\r\\n    console.log(true  = new Boolean(true));  // false\\r\\n\\r\\n```\\r\\n\\r\\n因为 true 是基本类型，new Boolean(true)是一个对象\\r\\n\\r\\n### String\\r\\n\\r\\nJavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无论你在 string 类型上调用何种方法，都不会对值有改变。\\r\\n\\r\\nString 有最大长度是 2^53 - 1，但是这个最大长度并不是你理解的字符数，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。\\r\\n\\r\\n### Number\\r\\n\\r\\nJavaScript 中的 Number 类型有 (2^64 - 2^53+3) 个值。JavaScript 采用 IEEE 754 双精度版本(64 位)。\\r\\n\\r\\n> 指数为 2^e - 1 且尾数的小数部分全 0，这个数字是 ±∞。（符号位决定正负）\\r\\n\\r\\n> 指数为 2^e - 1 且尾数的小数部分非 0，这个数字是 NaN。\\r\\n\\r\\n其中 NaN，占用了 9007199254740990 位，即（2^53-2）；±∞ 占用两位。但是表示了三个直观的量。\\r\\n\\r\\nJavaScript 中的数字是 64-bits 的双精度，所以加减一下，一共有(2^64 - 2^53 + 3)个值。\\r\\n\\r\\n64 位双精度在计算机中存储占用 8 字节，64 位，有效位数为 16 位。其中符号位，指数位和尾数部分分别为 1, 11, 52。取值范围取决于指数位，计算精度取决于尾数位（小数）。\\r\\n\\r\\n小数位是 52 位（二进制），换算为十进制则只能百分百能保证 15 位。超过该精度（二进制 52 位，十进制 15 位）的小数运算将会被截取，造成精度损失和计算结果的不准确。\\r\\n\\r\\n```\\r\\n\\tconsole.log( 0.000000000000001 <= Number.EPSILON ); // false\\r\\n\\tconsole.log( 0.0000000000000001 <= Number.EPSILON ); // true\\r\\n\\r\\n```\\r\\n\\r\\n所以 JavaScript 提供的最小精度值 Number.EPSILON 为 2.220446049250313e-16 也就是\\r\\n小于 16 位小数(10 进制)。\\r\\n\\r\\n```\\r\\n\\tconsole.log( 2.220446049250313e-16.toString(2) );\\r\\n\\t// 0.0000000000000000000000000000000000000000000000000001\\r\\n\\t// 52位小数(2进制)\\r\\n```\\r\\n\\r\\n##### 为什么 0.1 + 0.2 != 0.3\\r\\n\\r\\n计算机计算都是用二进制的。\\r\\n\\r\\n问：要把小数装入计算机，总共分几步？你猜对了，3 步。\\r\\n\\r\\n- 第一步：转换成二进制。\\r\\n- 第二步：用二进制科学计算法表示。\\r\\n- 第三步：表示成 IEEE 754 形式。\\r\\n\\r\\n  0.1 二进制计算过程\\r\\n\\r\\n```\\r\\n\\t0.1*2=0.2========取出整数部分0\\r\\n\\t0.2*2=0.4========取出整数部分0\\r\\n\\t0.4*2=0.8========取出整数部分0\\r\\n\\t0.8*2=1.6========取出整数部分1\\r\\n\\t0.6*2=1.2========取出整数部分1　\\r\\n\\t0.2*2=0.4========取出整数部分0\\r\\n\\t0.4*2=0.8========取出整数部分0\\r\\n\\t0.8*2=1.6========取出整数部分1\\r\\n\\t0.6*2=1.2========取出整数部分1\\r\\n\\t……\\r\\n```\\r\\n\\r\\n得到一个无限循环的二进制小数 0.000110011…\\r\\n\\r\\n用科学计数法表示\\r\\n\\r\\n0.000110011(0011) == 1.100110011(0011)\\\\*2^-4 // (0011) 表示循环\\r\\n\\r\\n> 任何一个 r 进制数 N 都可以写成（N）r=(+/-)S\\\\*r(+/-e)这种科学计数法\\r\\n\\r\\n> 其中 N 表示需要表示的数，r 表示进制，S 表示尾数，N 的有效位数字，e 表示阶码，代表小数点的位置\\r\\n\\r\\n表示成 IEEE 754 形式\\r\\n\\r\\n1. 正数 固符号位为 0\\r\\n2. 尾数 由于由于第一位使用是 1，固取(首位 1 干掉了) .100110011(0011)\\r\\n3. 指数 -4 + 1023(偏移量), 1019 转换为二进制就是 01111111011\\r\\n\\r\\n组合在一起就是 0-01111111011-100110011(0011)\\r\\n\\r\\n因为 IEEE 754 64 位只能存储 52 位尾数，剩下的需要舍入。\\r\\n\\r\\n因此 0.1 实际存储时的位模式是 0-01111111011-1001100110011001100110011001100110011001100110011010；\\r\\n\\r\\n0.2 同理得到 0-01111111100-1001100110011001100110011001100110011001100110011010；\\r\\n\\r\\n相加得到 0-01111111101-0011001100110011001100110011001100110011001100110100;转换为十进制即为 0.30000000000000004。\\r\\n\\r\\n> 单精度 32 位的 偏移量是 Math.pow(2,8)/2 -1 == 127 ，双精度 64 位的偏移量是 Math.pow(2,11)/2 -1 == 1023\\r\\n\\r\\n> 因为所有数的二进制科学计数都可以写成 1.xxxx，所以是固定的，取消默认 1，这样可以多出一位存储空间。\\r\\n\\r\\n##### 其它\\r\\n\\r\\n- 指数域不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数的计算值减去 127（或 1023），得到真实值，再将尾数前加上第一位的 1。\\r\\n- 指数域全为 0。这时，浮点数的指数等于 1-127（或者 1-1023），尾数不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。\\r\\n- 指数域全为 1。这时，如果尾数全为 0，表示 ± 无穷大（正负取决于符号位 s）；如果尾数不全为 0，表示这个数不是一个数（NaN）。\\r\\n\\r\\n### symbol\\r\\n\\r\\n```\\r\\n\\tvar o = new Object\\r\\n\\r\\n\\to[Symbol.iterator] = function() {\\r\\n\\t\\tvar v = 0\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tnext: function() {\\r\\n\\t\\t\\t\\treturn { value: v++, done: v > 10 }\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tfor(var v of o)\\r\\n\\t\\tconsole.log(v); // 0 1 2 3 ... 9\\r\\n```\\r\\n\\r\\n代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。\\r\\n\\r\\n这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。\\r\\n\\r\\n这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。\\r\\n\\r\\n参考链接\\r\\n\\r\\n[numberInJavaScript](http://www.yangshengdonghome.com/2016/06/19/numberInJavaScript/)\\r\\n\\r\\n[重学前端](https://time.geekbang.org/column/154)\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/type1.md\n// module id = LYLl\n// module chunks = 1","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('h2',[_vm._v(\"用一定的词法和语法,去表达一定语义,最终操作运行时\")]),_vm._v(\" \"),_c('router-view')],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-cde7377e\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-cde7377e\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./App.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-cde7377e\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./App.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.vue\n// module id = null\n// module chunks = ","<template>\r\n  <div id=\"app\">\r\n    <h2>用一定的词法和语法,去表达一定语义,最终操作运行时</h2>\r\n    <router-view/>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'App'\r\n}\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n  margin-top: 60px;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/App.vue","\r\n<template>\r\n\t<div>\r\n  <div id=\"main\" style=\"height:800px;\" >\r\n  </div>\r\n\t<el-dialog\r\n\t\t:title=\"title\"\r\n\t\t:visible.sync=\"dialogVisible\"\r\n\t\twidth=\"70%\"\r\n\t\tcenter>\r\n\t\t<div v-html=\"compiledMarkdown\"></div>\r\n\t\t<span slot=\"footer\" class=\"dialog-footer\">\r\n\t\t\t<el-button @click=\"dialogVisible = false\">取 消</el-button>\r\n\t\t\t<el-button type=\"primary\" @click=\"dialogVisible = false\">确 定</el-button>\r\n\t\t</span>\r\n\t</el-dialog>\r\n\r\n\t</div>\r\n\t\r\n</template>\r\n\r\n<script>\r\nimport marked from 'marked'\r\nexport default {\r\n  data() {\r\n    return {\r\n      title: '', // 标题\r\n      dialogVisible: false, // dialog弹出判定\r\n      input: '', // 引入md文件名字\r\n      // 树数据\r\n      data: {\r\n        name: '前端知识构架',\r\n        children: [\r\n          {\r\n            name: 'javascript',\r\n            children: [\r\n              {\r\n                name: '运行时',\r\n                children: [\r\n                  {\r\n                    name: '数据结构',\r\n                    children: [\r\n                      {\r\n                        name: '类型',\r\n                        children: [\r\n                          {\r\n                            name: '基本类型',\r\n                            file: 'type1'\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n                            name: '对象',\r\n                            file: 'type2'\r\n                          },\r\n                          {\r\n                            name: '类型转换',\r\n                            file: 'type3'\r\n                          }\r\n                        ]\r\n                      },\r\n                      {\r\n                        name: '实例',\r\n                        children: [\r\n                          {\r\n                            name: '应用和机制'\r\n                          }\r\n                        ]\r\n                      }\r\n                    ]\r\n                  },\r\n                  {\r\n                    name: '执行过程（）',\r\n                    children: [\r\n                      { name: '事件循环' },\r\n                      { name: '做任务的执行' },\r\n                      { name: '函数的执行' },\r\n                      { name: '语句级的执行' }\r\n                    ]\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                name: '文法',\r\n                children: [\r\n                  {\r\n                    name: '词法'\r\n                    // value: 4116\r\n                  },\r\n                  {\r\n                    name: '语法'\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                name: '语义',\r\n                children: [\r\n                  {\r\n                    name: '语义化标签',\r\n                    file: 'semantic1'\r\n                  }\r\n                ]\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            name: 'HTML&CSS',\r\n            children: [\r\n              {\r\n                name: 'HTML',\r\n                children: [\r\n                  {\r\n                    name: '元素',\r\n                    children: [\r\n                      { name: '文档元信息' },\r\n                      { name: '语义相关内容' },\r\n                      { name: '链接' },\r\n                      { name: '替换型元素' },\r\n                      { name: '表单' },\r\n                      { name: '表格' },\r\n                      { name: '总集' }\r\n                    ]\r\n                  },\r\n                  {\r\n                    name: '语言',\r\n                    children: [{ name: '实体' }, { name: '命名空间' }]\r\n                  },\r\n                  {\r\n                    name: '补充标准'\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                name: 'CSS',\r\n                children: [\r\n                  {\r\n                    name: '语言',\r\n                    children: [{ name: '@rule' }, { name: '选择器' }, { name: '单位' }]\r\n                  },\r\n                  {\r\n                    name: '功能',\r\n                    children: [\r\n                      {\r\n                        name: '布局',\r\n                        children: [{ name: '正常流' }, { name: '弹性布局' }]\r\n                      },\r\n                      {\r\n                        name: '绘制',\r\n                        children: [{ name: '颜色和形状' }, { name: '文字相关' }]\r\n                      },\r\n                      {\r\n                        name: '交互',\r\n                        children: [{ name: '动画' }, { name: '其他交互' }]\r\n                      }\r\n                    ]\r\n                  }\r\n                ]\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            name: '浏览器的实现原理和API',\r\n            children: [\r\n              {\r\n                name: '实现原理',\r\n                children: [\r\n                  { name: '解析' },\r\n                  { name: '构建DOM树' },\r\n                  { name: '计算CSS' },\r\n                  { name: '渲染、合成和绘制' }\r\n                ]\r\n              },\r\n              {\r\n                name: 'API',\r\n                children: [\r\n                  { name: 'DOM' },\r\n                  { name: 'CSSOM' },\r\n                  { name: '事件' },\r\n                  { name: 'API总集合' }\r\n                ]\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            name: '前端工程实践',\r\n            children: [\r\n              { name: '性能' },\r\n              { name: '工具链' },\r\n              { name: '持续集成' },\r\n              { name: '搭建系统' },\r\n              { name: '架构与基础库' }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    this.Chart() //\r\n    this.mark()\r\n  },\r\n  computed: {\r\n    compiledMarkdown: function() {\r\n      // markdown渲染计算\r\n      return marked(this.input, { sanitize: false })\r\n    }\r\n  },\r\n  methods: {\r\n    mark() {\r\n      // markdown插件配置\r\n      let renderMD = new marked.Renderer()\r\n      marked.setOptions({\r\n        renderer: renderMD,\r\n        gfm: true,\r\n        tables: true,\r\n        breaks: false,\r\n        pedantic: false,\r\n        sanitize: false, // 忽略任何已经输入的html代码（标签）\r\n        smartLists: true,\r\n        smartypants: false,\r\n        highlight: function(code, lang) {\r\n          // console.log('code', code)\r\n          // return   hljs.highlight(lang, code, false,true).value;\r\n          return hljs.highlightAuto(code).value\r\n        }\r\n      })\r\n    },\r\n    Chart() {\r\n      let myChart = this.$echarts.init(document.getElementById('main'))\r\n      let that = this\r\n      myChart.on('click', function(params) {\r\n        if (params.data.children) {\r\n          // 如果不是最终子节点\r\n          return\r\n        } else if (!params.data.file) {\r\n\t\t\t\t\t// 如果没有文章\t\t\t\r\n          that.$message({\r\n            message: '暂时没有相关文章',\r\n            type: 'warning'\r\n          })\r\n        } else {\r\n          // 树分支末端点击事件\r\n          that.title = params.name\r\n          // 根据点击file名字,动态拿markdown文件内容\r\n          that.input = require(`../article/${params.data.file}.md`)\r\n          that.dialogVisible = true\r\n          // console.log(that.compiledMarkdown)\r\n        }\r\n      })\r\n      let option = {\r\n        // 树配置\r\n        tooltip: {\r\n          trigger: 'item',\r\n          triggerOn: 'mousemove'\r\n        },\r\n        series: [\r\n          {\r\n            type: 'tree',\r\n\r\n            data: [this.data],\r\n\r\n            top: '1%',\r\n            left: '10%',\r\n            bottom: '1%',\r\n            right: '20%',\r\n\r\n            symbolSize: 10,\r\n\r\n            label: {\r\n              normal: {\r\n                position: 'left',\r\n                verticalAlign: 'middle',\r\n                align: 'right',\r\n                fontSize: 16\r\n              }\r\n            },\r\n\r\n            leaves: {\r\n              label: {\r\n                normal: {\r\n                  position: 'right',\r\n                  verticalAlign: 'middle',\r\n                  align: 'left'\r\n                }\r\n              }\r\n            },\r\n            initialTreeDepth: 10, // 默认展开深度\r\n            expandAndCollapse: true,\r\n            animationDuration: 550,\r\n            animationDurationUpdate: 750\r\n          }\r\n        ]\r\n      }\r\n      myChart.hideLoading()\r\n      myChart.setOption(option)\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\r\n<style>\r\n\r\nh1,h2,h3 {\r\n\tcolor: #000;\r\n}\r\nul {\r\n  padding: 10px;\r\n}\r\nli {\r\n  margin: 0 10px;\r\n}\r\na {\r\n  color: #42b983;\r\n}\r\npre {\r\n\tbackground: #252525;\r\n\tpadding: 10px 15px;\r\n\tborder-radius: 8px;\r\n}\r\nblockquote {\r\n\tborder-left: 3px solid #ffa986;\r\n\tpadding-left: 5px;\r\n\tmargin-left: 1em;\r\n}\r\ntable, tr, th, td {\r\n\tborder:1px solid;\r\n\tpadding: 5px 10px;\r\n\tborder-collapse:collapse; \r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/components/home.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticStyle:{\"height\":\"800px\"},attrs:{\"id\":\"main\"}}),_vm._v(\" \"),_c('el-dialog',{attrs:{\"title\":_vm.title,\"visible\":_vm.dialogVisible,\"width\":\"70%\",\"center\":\"\"},on:{\"update:visible\":function($event){_vm.dialogVisible=$event}}},[_c('div',{domProps:{\"innerHTML\":_vm._s(_vm.compiledMarkdown)}}),_vm._v(\" \"),_c('span',{staticClass:\"dialog-footer\",attrs:{\"slot\":\"footer\"},slot:\"footer\"},[_c('el-button',{on:{\"click\":function($event){_vm.dialogVisible = false}}},[_vm._v(\"取 消\")]),_vm._v(\" \"),_c('el-button',{attrs:{\"type\":\"primary\"},on:{\"click\":function($event){_vm.dialogVisible = false}}},[_vm._v(\"确 定\")])],1)])],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-57c0237a\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/home.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-57c0237a\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./home.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-57c0237a\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./home.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/home.vue\n// module id = null\n// module chunks = ","import Vue from 'vue'\r\nimport Router from 'vue-router'\r\nimport home from '@/components/home'\r\n\r\nVue.use(Router)\r\n\r\nexport default new Router({\r\n  routes: [\r\n    {\r\n      path: '/',\r\n      name: 'home',\r\n      component: home\r\n    }\r\n  ]\r\n})\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/index.js","// The Vue build version to load with the `import` command\r\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\r\nimport Vue from 'vue'\r\nimport App from './App'\r\nimport router from './router'\r\nimport echarts from 'echarts';\r\nimport { Button, Dialog, Message } from 'element-ui'\r\nimport 'element-ui/lib/theme-chalk/index.css'\r\n\r\nVue.prototype.$echarts = echarts; \r\nVue.use(Button)\r\nVue.use(Dialog)\r\nVue.prototype.$message = Message\r\n\r\nVue.config.productionTip = false\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: '#app',\r\n  router,\r\n  components: { App },\r\n  template: '<App/>'\r\n})\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","module.exports = echarts;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"echarts\"\n// module id = Pg0u\n// module chunks = 1","module.exports = \"刚刚无意之中在网上看到 `web worker` 这个词，瞬间跌入了回忆的深渊，什么 `serviceWorker`、`walking dead`、亲爱的长者 乱七八糟一齐涌了出来，就是没有 `web worker`，最后颓废的发现，原来关于 `worker` 相关的东西自己已经忘干净了。\\r\\n\\r\\n不过隐约记得这东西用起来不很复杂，于是果断上 MDN 看看文档，但是又无意中看到 `MessageChannel` 这个词，很明显幼小的心灵又被一个陌生的词汇狠狠的鞭笞了一下。忍不住点进去看了一下关于 `MessageChannel` 的资料，发现这行代码 ([来源](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel/MessageChannel)):\\r\\n\\r\\n```js\\r\\notherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\\r\\n```\\r\\n\\r\\n蛤？原来 `postMessage` 方法可以接收第 `3` 个参数？那请问第三个参数是什么意思？文章里说的 `MessgaePort` 对象又是什么？想到这么多问题自己还完全摸不着边，而且问题之间环环相扣，于是仔细深究了一番，下面是一些笔记。\\r\\n\\r\\n#### 什么是 MessageChannel ?\\r\\n首先，`MessageChannel` 是一个构造函数，创建一对相互连接的 `MessagePort` 对象。\\r\\n\\r\\n```js\\r\\nvar mc=new MessageChannel;\\r\\nmc.port1.onmessage=function(e){console.log(\\\"port1：\\\"+e.data);};\\r\\nmc.port2.onmessage=function(e){console.log(\\\"port2：\\\"+e.data);};\\r\\nmc.port1.postMessage(\\\"1\\\"); //会在port2的message事件收到\\r\\nmc.port2.postMessage(\\\"2\\\"); //会在port1的message事件收到\\r\\n```\\r\\n\\r\\n(这段代码的[来源](https://www.web-tinker.com/article/20320.html))\\r\\n\\r\\n上面说的一对相互连接的 `MessagePort` 对象分别是 `mc.port1` 和 `mc.port2`，他们可以相互给对方发送消息，并且处理接收到的消息。这就是 `MessageChannel` 最基本的用法，很简单，但是看起来很无用。\\r\\n\\r\\n#### postMessage 很好用\\r\\n我们知道 `postMessage` 可以用于 `worker` 和跨文档消息传递机制，用起来也很简单，只要记住 `postMessage` 是”自己给自己发消息“，我们以后者为例：\\r\\n\\r\\n```js\\r\\n// index.html\\r\\nvar iframe = document.querySelector('iframe')\\r\\niframe.onload = () => {\\r\\n  let w = iframe.contentWindow\\r\\n\\r\\n  w.onmessage = (e) => {\\r\\n    console.log(e.data)\\r\\n  }\\r\\n  w.postMessage('initialize', '*')\\r\\n}\\r\\n\\r\\n// iframe.html\\r\\nonmessage = (e) => {\\r\\n  console.log(e.data)\\r\\n  window.postMessage(`Received message: ${e.data}`)\\r\\n}\\r\\n```\\r\\n\\r\\n上面这段代码逻辑非常简单，`iframe` 自己给自己发消息并处理接收到的消息，但是可能不好理解的就是所谓的 “自己给自己发消息”。在我们正常的认知中，发消息通常都是一方发给另外一方，哪有自己给自己发消息的 (自言自语除外)。而且因为自发消息的特性，在不同的上下文中 (不同的页面或者 worker 与 main thread 间)，`postMessage` 和 `onmessage` 在写法上看起来又不像是 ”自己给自己发“：在 `index.html` 中写法是 `iframe.contentWindow.postMessage`，在 `iframe.html` 中写法又是 `window.postMessage`。总之，如果不习惯的话从文字上看起来会觉得这种写法有些别扭，不过好在我们还有另一种写法。\\r\\n\\r\\n#### MessageChannel 让通信变得更简单\\r\\n上面说到 `MessageChannel` 构造函数会创建一对相互关联的 `MessagePort` 对象，怎么理解 `MessagePort` 对象呢？可以把一个 `MessagePort` 对象当成消息传递的管道，我们可以通过这两个对象来进行消息的传递，想象一下现实生活中的两个人通过手机打电话，一个 `MessagePort` 对象就是一个手机。\\r\\n\\r\\n`MessageChannel` 其实就更好理解了，不再是自己给自己发消息，而是一方发给另一方，也即是 `mc.port1` 和 `mc.port2` 相互传递处理消息。\\r\\n\\r\\n但是怎么利用 `MessageChannel` 来让我们现有的消息传递机制更加简单清晰呢？答案正是我们上面说的 `window.postMessage` 方法的第三个参数 (`MessagePort.postMessage` 里是第二个参数)。\\r\\n\\r\\n这个参数是可选的，而且如果有的话必须是 `Array/ArrayLike`，表示 “跟随信息一起传送的可转让对象的序列”，意思就是把这些可转让对象的所有权转让给目的上下文 **(注意只有 `MessagePort` 和 `ArrayBuffer` 对象可以被转移)**。\\r\\n\\r\\n什么意思呢？看文章里的第一行代码：\\r\\n\\r\\n```js\\r\\notherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\\r\\n```\\r\\n\\r\\n这里 `channel.port2` 就被转移到 `otherWindow` 上下文中去了，也就是现在 `channel.port2` 能够被 `otherWindow` 上下文访问到了。不过这样有什么用呢？我们不还是用了 `postMessage` 方法吗？\\r\\n\\r\\n其实很好理解，想像一下，现在你跟你的一个小伙伴分隔两地，通信是通过邮政寄信的方式，很不方便，但是某天你突然得到两个电话，然后通过邮政发给你的小伙伴一个，这样等小伙伴收到电话你们就能愉快的打电话了。翻译过来就是：通过 `postMessage` 把其中一个 `MessagePort` 对象传递给需要通信的一方，然后双方就可以通过 `MessagePort` 对象相互通信。\\r\\n\\r\\n好了就说这么多，下面直接上完整的代码，很好理解：\\r\\n\\r\\n```\\r\\n// index.html\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n<head>\\r\\n    <meta charset=\\\"utf-8\\\">\\r\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\r\\n    <title></title>\\r\\n</head>\\r\\n<body>\\r\\n    <iframe src=\\\"iframe.html\\\" frameborder=\\\"0\\\"></iframe>\\r\\n    <script>\\r\\n        var channel = new MessageChannel\\r\\n        var port = channel.port1\\r\\n\\r\\n        var iframe = document.querySelector('iframe')\\r\\n        iframe.onload = () => {\\r\\n          iframe.contentWindow.postMessage('initialize', '*', [channel.port2])\\r\\n        }\\r\\n\\r\\n        port.addEventListener('message', (e) => {\\r\\n          console.log(e.data, e)\\r\\n        }, false)\\r\\n\\r\\n        // 因为我们用的是 addEventListener 而不是 onmessage,\\r\\n        // 所以需要调用 port.start 方法\\r\\n        // 见: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\\r\\n        port.start()        \\r\\n    </script>\\r\\n</body>\\r\\n</html>\\r\\n\\r\\n// iframe.html\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n<head>\\r\\n    <meta charset=\\\"utf-8\\\">\\r\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\r\\n    <title></title>\\r\\n</head>\\r\\n<body>\\r\\n    <script>\\r\\n      onmessage = (e) => {\\r\\n        // index.html 传递过来的 MessagePort 对象\\r\\n        // 通过 e.ports[0] 获取\\r\\n        var port = e.ports[0]\\r\\n\\r\\n        // 现在可以愉快的通过 port\\r\\n        // 进行消息传递\\r\\n        port.onmessage = (e) => {\\r\\n          console.log('from iframe: ' + e.data)\\r\\n        }\\r\\n        port.postMessage('sad')       \\r\\n      }\\r\\n    </script>   \\r\\n</body>\\r\\n</html>\\r\\n```\\r\\n\\r\\n#### 总结\\r\\n`MessageChannel` 是基本的双向信息传输管道，可以把它想象成 `window.postMessage`/`window.onmessage` 的另一种更加清晰的替代方案。最后要说的一点就是，sharedWorker 默认使用了 `MessagePort` 进行消息传递，有兴趣的同学可以自行探索。\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/typex.md\n// module id = avjR\n// module chunks = 1","var map = {\n\t\"./annualPlan.md\": \"38D4\",\n\t\"./semantic1.md\": \"4DoG\",\n\t\"./type1.md\": \"LYLl\",\n\t\"./type2.md\": \"Gotm\",\n\t\"./type3.md\": \"gu2x\",\n\t\"./typex.md\": \"avjR\"\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"geK+\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article ^\\.\\/.*\\.md$\n// module id = geK+\n// module chunks = 1","module.exports = \"###### ARRON 2019 年 2 月 12 日\\r\\n\\r\\nJS里的类型转换有四种情况,原始类型转Object的一般不用手动处理,默认的装箱转换会自动处理.\\r\\n\\r\\n- 转换为布尔值\\r\\n- 转换为数字\\r\\n- 转换为字符串\\r\\n- 转换为对象\\r\\n\\r\\n\\r\\n原始值 | Boolean | Number | String | Object\\r\\n---|---|---|---|---\\r\\nNull | false | 0 | \\\"null\\\"| TypeError\\r\\nUndefined | false | NaN | \\\"undefined\\\"| TypeError\\r\\nBoolean(true) | - | 1 | \\\"true\\\" | 装箱转换\\r\\nBoolean(false) | - | 0 | \\\"false\\\" | 装箱转换\\r\\nNumber | 除了0/\\\\-0/NaN都为true| - | #NumberToString | 装箱转换\\r\\nString | \\\"\\\"为flase | #StringToNumber | -| 装箱转换\\r\\nSymbol | true | TypeError | TypeError | 装箱转换\\r\\nObject | true | 拆箱转换 | 拆箱转换 | -\\r\\n\\r\\n> 开箱转换,拆箱转换看上一篇< 基本类型 >\\r\\n> 关于null、undefined转换为Object，在权威指南中写的是TypeError，但这里其实用Object()来转换时，会返回一个空对象{}。但这个空对象是没有原始值 [[PrimitiveValue]] 的，只是一个空对象。\\r\\n\\r\\nObject拆箱转换补充\\r\\n\\r\\n原始值 | Boolean | Number | String \\r\\n---|---|---|---\\r\\n{}任意对象 | true | NaN | toString()\\r\\n[] | true | 0 | \\\"\\\"\\r\\n[8]单数字数组 | true | 9 | \\\"9\\\"\\r\\n[\\\"a\\\",4,true] | true | NaN | \\\"a,4,true\\\"\\r\\nfunction(){} | true | NaN | \\\"function(){}\\\"\\r\\n\\r\\n### NumberToString\\r\\n\\r\\n一般来说,Number都会转成相同表示方法的字符串。但是，当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示。实际上这个时候的Number也是用科学计数法表示的。\\r\\n\\r\\n\\r\\n```\\r\\nlet a = 1111111111111111111111111\\r\\nconsole.log(a);\\r\\n// 1.1111111111111111e+24\\r\\nconsole.log(a.toString());\\r\\n// '1.1111111111111111e+24'\\r\\n```\\r\\n\\r\\n### StringToNumber\\r\\n\\r\\n字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：\\r\\n\\r\\n```\\r\\nNumber(\\\"123\\\")     // 123\\r\\nNumber(\\\"\\\")        // 0\\r\\nNumber(\\\"0x11\\\")    // 17\\r\\nNumber(\\\"0b11\\\")    // 3\\r\\nNumber(\\\"0o11\\\")    // 9\\r\\nNumber(\\\"foo\\\")     // NaN\\r\\nNumber(\\\"100a\\\")    // NaN\\r\\n```\\r\\n此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：\\r\\n\\r\\n- 1e22\\r\\n- 1e-3\\r\\n\\r\\n需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。\\r\\n\\r\\n### parseInt、parseFloat\\r\\n```\\r\\nparseFloat(\\\"3.14\\\");  // 3.14\\r\\nparseFloat(\\\"314e-2\\\");  // 3.14\\r\\nparseFloat(\\\"0.0314E+2\\\");  // 3.14\\r\\nparseFloat(\\\"3.14more non-digit characters\\\");  // 3.14\\r\\nparseFloat(\\\"FF2\\\");  // NaN\\r\\n```\\r\\n\\r\\n在任何环境下，都建议传入 parseInt 的第二个参数。\\r\\n\\r\\n```\\r\\nparseInt(4.7 * 1e22, 10); // 非常大的数值变成 4\\r\\nparseInt(0.00000000000434, 10); // 非常小的数值变成 4\\r\\n\\r\\nparseInt(\\\"Hello\\\", 8); // NaN 根本就不是数值\\r\\nparseInt(\\\"546\\\", 2);   //  NaN  除了“0、1”外，其它数字都不是有效二进制数字\\r\\n```\\r\\n\\r\\n一些数中可能包含e字符（例如6.022e23），使用parseInt去截取包含e字符数值部分会造成难以预料的结果。例如：\\r\\n```\\r\\nparseInt(\\\"6.022e23\\\", 10);        // 返回 6\\r\\nparseInt(6.022e2, 10);          // 返回 602\\r\\n```\\r\\n\\r\\n### 运算符\\r\\n\\r\\n#### 加法运算符\\r\\n- 运算中其中一方为字符串，那么就会把另一方也转换为字符串\\r\\n- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串\\r\\n\\r\\n```\\r\\n1 + '1' // '11'\\r\\ntrue + true // 2\\r\\n4 + [1,2,3] // \\\"41,2,3\\\"\\r\\n\\r\\n```\\r\\n加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。\\r\\n```\\r\\n'3' + 4 + 5 // \\\"345\\\"\\r\\n3 + 4 + '5' // \\\"75\\\"\\r\\nconsole.log('a' + - 'b')  // aNaN\\r\\n```\\r\\n\\r\\n对于除了加法的运算符（比如减法、除法和乘法）来说，都不会发生重载，只要其中一方是数字，那么另一方就会被转为数字\\r\\n```\\r\\n4 * '3' // 12\\r\\n4 * [] // 0\\r\\n4 * [1, 2] // NaN\\r\\n```\\r\\n\\r\\n#### 比较运算符\\r\\n\\r\\nJavaScript 一共提供了8个比较运算符。\\r\\n\\r\\n- \\\\> 大于运算符\\r\\n- < 小于运算符\\r\\n- <= 小于或等于运算符\\r\\n- \\\\>= 大于或等于运算符\\r\\n- == 相等运算符\\r\\n- === 严格相等运算符\\r\\n- != 不相等运算符\\r\\n- !== 严格不相等运算符\\r\\n\\r\\n这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。\\r\\n\\r\\n##### 非相等运算符\\r\\n如果两个运算子都是原始类型的值，则是先转成数值再比较。\\r\\n```\\r\\n5 > '4' // true\\r\\n// 等同于 5 > Number('4')\\r\\n// 即 5 > 4\\r\\n\\r\\ntrue > false // true\\r\\n// 等同于 Number(true) > Number(false)\\r\\n// 即 1 > 0\\r\\n\\r\\n2 > true // true\\r\\n// 等同于 2 > Number(true)\\r\\n// 即 2 > 1\\r\\n```\\r\\n任何值（包括NaN本身）与NaN比较，返回的都是false。\\r\\n```\\r\\n1 > NaN // false\\r\\n1 <= NaN // false\\r\\n'1' > NaN // false\\r\\n'1' <= NaN // false\\r\\nNaN > NaN // false\\r\\nNaN <= NaN // false\\r\\n```\\r\\n如果运算子是对象，会转为原始类型的值，再进行比较。\\r\\n```\\r\\nlet a = {\\r\\n  valueOf() {\\r\\n    return 0\\r\\n  },\\r\\n  toString() {\\r\\n    return '1'\\r\\n  }\\r\\n}\\r\\na > -1 // true\\r\\n```\\r\\n上面代码，重写valueOf和toString，拆箱转换，大于运算符hint为Number，先执行valueOf。如果没重写valueOf和toString，valueOf会拿到对象本身。\\r\\n\\r\\n对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，toString会拿到[Object Object]。\\r\\n\\r\\n如果toString方法返回的不是原始类型的值，结果就会报错。\\r\\n\\r\\n```\\r\\nlet a = {\\r\\n  valueOf() {\\r\\n    return {}\\r\\n  },\\r\\n  toString() {\\r\\n    return {}\\r\\n  }\\r\\n}\\r\\na > -1  // TypeError\\r\\n```\\r\\n'[Object Object]'转Number是NaN，NaN和任何比较都是false\\r\\n```\\r\\nlet a = {}\\r\\na > 1 // false\\r\\n```\\r\\n\\r\\n所以\\r\\n```\\r\\nlet a = {}\\r\\na + 1  // [object Object]1\\r\\n```\\r\\n##### 严格相等(\\\\=\\\\=\\\\=) 和 相等(==)\\r\\n\\r\\n严格相等\\r\\n\\r\\n原始类型，值和类型全部相同，返回true，否则返回false\\r\\n```\\r\\n1 === 0x1 // true\\r\\ntrue === \\\"true\\\" // false\\r\\nNaN === NaN  // false\\r\\n+0 === -0 // true\\r\\n```\\r\\n\\r\\n复合类型，两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。\\r\\n```\\r\\n{} === {} // false\\r\\n[] === [] // false\\r\\n(function () {} === function () {}) // false\\r\\n```\\r\\n如果两个变量引用同一个对象\\r\\n```\\r\\nvar v1 = {};\\r\\nvar v2 = v1;\\r\\nv1 === v2 // true\\r\\n```\\r\\n对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。\\r\\n```\\r\\nvar obj1 = {};\\r\\nvar obj2 = {};\\r\\n\\r\\nobj1 > obj2  // false\\r\\nobj1 < obj2  // false\\r\\nobj1 === obj2  // false\\r\\n```\\r\\nundefined和null与自身严格相等，所以\\r\\n```\\r\\nvar v1;\\r\\nvar v2;\\r\\nv1 === v2  // true\\r\\n```\\r\\n相等\\r\\n\\r\\n原始类型的值会转换成数值再进行比较。\\r\\n\\r\\n```\\r\\n1 == true // true\\r\\n// 等同于 1 === Number(true)\\r\\n\\r\\n0 == false // true\\r\\n// 等同于 0 === Number(false)\\r\\n\\r\\n2 == true // false\\r\\n// 等同于 2 === Number(true)\\r\\n\\r\\n2 == false // false\\r\\n// 等同于 2 === Number(false)\\r\\n\\r\\n'true' == true // false\\r\\n// 等同于 Number('true') === Number(true)\\r\\n// 等同于 NaN === 1\\r\\n\\r\\n'' == 0 // true\\r\\n// 等同于 Number('') === 0\\r\\n// 等同于 0 === 0\\r\\n\\r\\n'' == false  // true\\r\\n// 等同于 Number('') === Number(false)\\r\\n// 等同于 0 === 0\\r\\n\\r\\n'1' == true  // true\\r\\n// 等同于 Number('1') === Number(true)\\r\\n// 等同于 1 === 1\\r\\n\\r\\n'\\\\n  123  \\\\t' == 123 // true\\r\\n// 因为字符串转为数字时，省略前置和后置的空格\\r\\n```\\r\\n\\r\\n对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。\\r\\n\\r\\n```\\r\\n// 对象与数值比较时，对象转为数值\\r\\n[1] == 1 // true\\r\\n// 等同于 Number([1]) == 1\\r\\n\\r\\n// 对象与字符串比较时，对象转为字符串\\r\\n[1] == '1' // true\\r\\n// 等同于 String([1]) == '1'\\r\\n[1, 2] == '1,2' // true\\r\\n// 等同于 String([1, 2]) == '1,2'\\r\\n\\r\\n// 对象与布尔值比较时，两边都转为数值\\r\\n[1] == true // true\\r\\n// 等同于 Number([1]) == Number(true)\\r\\n[2] == true // false\\r\\n// 等同于 Number([2]) == Number(true)\\r\\n```\\r\\n\\r\\nundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。\\r\\n\\r\\n```\\r\\nfalse == null // false\\r\\nfalse == undefined // false\\r\\n\\r\\n0 == null // false\\r\\n0 == undefined // false\\r\\n\\r\\nundefined == null // true\\r\\n```\\r\\n\\r\\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果。\\r\\n```\\r\\n2 == true           // false\\r\\n2 == false          // false\\r\\n\\r\\nfalse == 'false'    // false\\r\\nfalse == '0'        // true\\r\\n\\r\\nfalse == undefined  // false\\r\\nfalse == null       // false\\r\\nnull == undefined   // true\\r\\n\\r\\n' \\\\t\\\\r\\\\n ' == 0     // true\\r\\n```\\r\\n因此建议不要使用相等运算符（\\\\=\\\\=），最好显式转换数据类型，使用严格相等运算符（\\\\=\\\\=\\\\=）。\\r\\n\\r\\n参考链接\\r\\n\\r\\n[《JavaScript 标准参考教程（alpha）》 by 阮一峰](http://javascript.ruanyifeng.com/)\\r\\n\\r\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/article/type3.md\n// module id = gu2x\n// module chunks = 1"],"sourceRoot":""}