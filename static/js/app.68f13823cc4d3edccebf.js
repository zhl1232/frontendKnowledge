webpackJsonp([1],{"+BTi":function(r,n){},"38D4":function(r,n){r.exports="## 2019年度计划\r\n\r\n1万小时计划 (第184天/1095天)\r\n\r\n2018年计划结果基本超出预期，但超出预期的原因很大部分是因为环境。过程没做把控。所以之后的计划会做细化，以确保可以达到预期目标。\r\n\r\n2019年半年计划(第7天/180天)\r\n\r\n1. 重构前端知识架构 （第21天/91天）\r\n\r\n>   根据winter大神的 重学前端 为框架，穿插自己的理解学习和其它碎片知识。更新文章放在https://github.com/zhl1232/frontendKnowledge (文章每星期2篇,周结.现在第三篇写作中...8月10日前,知识架构涉及到的知识点全部填完)\r\n\r\n2. 每周至少四小时运动(周结,强制)\r\n\r\n> 挣钱再多,狗命要紧\r\n\r\n3. 算法.leetcode(17/210)\r\n\r\n> 暂定8月10日leetcode 210题,难度比例(7:2.5:0.5),基本每天一题,周结\r\n\r\n4. 英语(只做词汇量和阅读)\r\n\r\n> 每天20分钟,日结.\r\n\r\n5. 娱乐缓冲时间\r\n\r\n> 18年平均每天使用手机时间240分-300分.其中大概60分钟在看技术相关内容.每天玩手机时间压缩到180分,娱乐的正反馈转移到写文章和运动方面.时间多利用晚上和周末.\r\n\r\n# 砥砺前行\r\n> 2019年2月11日"},"4DoG":function(r,n){r.exports="###### ARRON  2019年2月6日\r\n\r\n### 语义类标签是什么，使用它有什么好处？\r\n\r\n语义类标签在视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义。\r\n\r\n语义是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是纯文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，我们需要依靠语义标签代为表达。\r\n\r\n#### 正确使用语义标签可以带来很多好处\r\n- 语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有 CSS 的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。\r\n- 除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。\r\n\r\n### 作为自然语言延伸的语义类标签\r\n\r\n我们说话并没有唯一的标准措辞，语义标签的使用也是一样。\r\n\r\n一个好玩的ruby语义标签,如果没有这个标签的话,想实现ruby展示还比较麻烦。\r\n\r\n```\r\n<ruby>\r\n  你 <rt>sha</rt>\r\n  好 <rt>bi</rt>\r\n</ruby>\r\n```\r\n<ruby>\r\n  你 <rt>sha</rt>\r\n  好 <rt>bi</rt>\r\n</ruby>\r\n\r\n语义化标签对开发者的友好更多的表现为消除歧义，比如em标签表示重音，强调内容\r\n```\r\n// 这是一句不带任何强调的句子\r\n<p>Cats are cute animals.</p>\r\n\r\n// em 包围 Cats，强调猫是种可爱的动物，而不是狗或者其他动物\r\n<p><em>Cats</em> are cute animals.</p>\r\n\r\n// em 包围 are，代表句子所说是事实，来反驳那些说猫不可爱的人\r\n<p>Cats <em>are</em> cute animals.</p>\r\n\r\n// em 包围 cute，强调猫是一种可爱的动物，而不是有人说的刻薄、讨厌的动物\r\n<p>Cats are <em>cute</em> animals.</p>\r\n\r\n// 这里强调猫是动物，而不是植物\r\n<p>Cats are cute <em>animals</em>.</p>\r\n\r\n```\r\n\r\n而strong表示着重内容，代表内容的强烈的重要性、严重性或者紧急性。\r\n```\r\n// 章节序号不重要，章节的名字才重要\r\n<h1>Chapter 1: <strong>The Praxis</strong></h1>\r\n```\r\n\r\n><h1>Chapter 1: <strong>The Praxis</strong></h1>\r\n\r\n### 作为标题摘要的语义类标签\r\n\r\nh1-h6 是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用 hgroup 标签。\r\n```\r\n<h1>JavaScript 对象</h1>\r\n<h2> 我们需要模拟类吗？</h2>\r\n<p>balah balah</p>\r\n```\r\n```\r\n<hgroup>\r\n<h1>JavaScript 对象 </h1>\r\n<h2> 我们需要模拟类吗？</h2>\r\n</hgroup>\r\n<p>balah balah</p>\r\n```\r\n\r\n### 作为整体结构的语义类标签\r\n\r\n最后一个场景是，随着越来越多的浏览器推出“阅读模式”，以及各种非浏览器终端的出现，语义化的 HTML 适合机器阅读的特性变得越来越重要。\r\n\r\n应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。\r\n\r\n```\r\n<body>\r\n    <header>\r\n        <nav>\r\n            ……\r\n        </nav>\r\n    </header>\r\n    <aside>\r\n        <nav>\r\n            ……\r\n        </nav>\r\n    </aside>\r\n    <section>……</section>\r\n    <section>……</section>\r\n    <section>……</section>\r\n    <footer>\r\n        <address>……</address>\r\n    </footer>\r\n</body>\r\n```\r\n一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。\r\n```\r\n<body>\r\n    <header>……</header>\r\n    <article>\r\n        <header>……</header>\r\n        <section>……</section>\r\n        <section>……</section>\r\n        <section>……</section>\r\n        <footer>……</footer>\r\n    </article>\r\n    <article>\r\n        ……\r\n    </article>\r\n    <article>\r\n        ……\r\n    </article>\r\n    <footer>\r\n        <address></address>\r\n    </footer>\r\n</body>\r\n```\r\nbody 里面有自己的 header 和 footer，然后里面是竖篇的 article，每一个 article 里面都有自己的 header、section、footer。这是一个典型的多文章结构。\r\n\r\n最后 footer 中包含 address，这是个非常容易被误用的标签。address 并非像 date 一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address 明确地只关联到 article 和 body。\r\n\r\n### 总结\r\n\r\n至此，我们可以回答是否要语义化的问题：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。本篇文中，我们至少涉及了三个明确的场景：\r\n\r\n- 自然语言表达能力的补充；\r\n- 文章标题摘要；\r\n- 适合机器阅读的整体结构。\r\n\r\n\r\n参考链接\r\n\r\n[重学前端](https://time.geekbang.org/column/154)"},GXEp:function(r,n){},Gotm:function(r,n){r.exports="###### ARRON 2019 年 2 月 14 日\r\n\r\n语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合。\r\n\r\nObject（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。\r\n\r\n对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。\r\n\r\n### JavaScript 对象的特征\r\n\r\n不论我们使用什么样的编程语言，参考 Grandy Booch《面向对象分析与设计》总结来看，对象有如下几个特点。\r\n- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。\r\n- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。\r\n- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。\r\n\r\njavascript的对象唯一标识性\r\n```\r\n    var o1 = { a: 1 };\r\n    var o2 = { a: 1 };\r\n    console.log(o1 == o2); // false\r\n```\r\n关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们。\r\n\r\n在 JavaScript 中，将状态和行为统一抽象为“属性”。\r\n\r\n```\r\n    var o = { \r\n        d: 1,\r\n        f() {\r\n            console.log(this.d);\r\n        }    \r\n    };\r\n```\r\n对象o有d和f两个属性。\r\n\r\n<strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong>\r\n\r\n为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。\r\n\r\n### JavaScript 对象的两类属性\r\n\r\n对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。\r\n\r\n先来说第一类属性，数据属性。数据属性具有四个特征。\r\n\r\n- value：就是属性的值。\r\n- writeable：决定属性能否被赋值。\r\n- enumerble：决定 for in 能否枚举该属性。\r\n- configurable：决定该属性能否被删除或者改变特征值。\r\n\r\n第二类属性是访问器属性（getter/setter）属性,它也有四个属性。\r\n- getter：函数或 undefined，在取属性值时被调用。\r\n- getter：函数或 undefined，在设置属性值时被调用。\r\n- enumerble：决定 for in 能否枚举该属性。\r\n- configurable：决定该属性能否被删除或者改变特征值。\r\n\r\n访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值。\r\n\r\n```\r\nvar o = {\r\n  a: 7,\r\n  get b() { \r\n    return this.a + 1;\r\n  },\r\n  set c(x) {\r\n    this.a = x / 2\r\n  }\r\n};\r\n\r\nconsole.log(o.a); // 7\r\nconsole.log(o.b); // 8\r\no.c = 50;\r\nconsole.log(o.a); // 25\r\n```\r\n\r\n我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：\r\n```\r\n    var o = { a: 1 };\r\n    o.b = 2;\r\n    //a 和 b 皆为数据属性\r\n    Object.getOwnPropertyDescriptor(o,\"a\") // {value: 1, writable: true, enumerable: true, configurable: true}\r\n    Object.getOwnPropertyDescriptor(o,\"b\") // {value: 2, writable: true, enumerable: true, configurable: true}\r\n```\r\n如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：\r\n```\r\n    var o = { a: 1 };\r\n    Object.defineProperty(o, \"b\", {value: 2, writable: false, enumerable: false, configurable: true});\r\n    //a 和 b 都是数据属性，但特征值变化了\r\n    Object.getOwnPropertyDescriptor(o,\"a\"); // {value: 1, writable: true, enumerable: true, configurable: true}\r\n    Object.getOwnPropertyDescriptor(o,\"b\"); // {value: 2, writable: false, enumerable: false, configurable: true}\r\n    o.b = 3;\r\n    console.log(o.b); // 2\r\n```\r\n其实Object.freeze(obj)就是改变obj的writable,configurable为false\r\n\r\n\r\n实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。\r\n\r\n### 对象类型的存储\r\n\r\n在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。\r\n\r\n![image](asstes/images/type2.png)\r\n\r\n```\r\nconst a = {}\r\nlet b = a\r\na.c = 666\r\nconsole.log(b.c)  // 666\r\n```\r\n因为b和a指向同一个内存指针。同时也说明了const常量是针对内存指针的常量，只是内存指针地址不能改变。\r\n\r\n![image](asstes/images/type1.png)\r\n\r\n### 函数传值\r\n\r\n参数传值是指函数调用时，给函数传递配置或运行参数的行为，包括通过call、apply 进行传值。\r\n\r\n基本类型和引用类型在变量复制的时候存在区别：\r\n\r\n- 原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的 value 而已。\r\n- 引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。复制是不会产生新的堆内存消耗。\r\n\r\njavascript 中所有函数参数都是按值传递，都是把形参复制给实参，只是基本数据类型复制的是原始值，而引用类型复制的是堆内存的地址。\r\n\r\n#### 基本类型传值\r\n```\r\nlet a = 1\r\nfunction foo(x) {\r\n    x = 2\r\n    console.log(x)\r\n}\r\nfoo(a)  // 2\r\nconsole.log(a)  // 1\r\n```\r\n它们在全局上下文和foo的上下文中各自保存了值1，且相互之间互不影响，我们对 a、x的读写操作，操作的是他们各自的值。\r\n\r\n#### 引用类型传值\r\n\r\n```\r\nlet a = {\r\n    abc: 1\r\n}\r\nfunction foo(x) {\r\n    x.abc = 2\r\n    console.log(x.abc)\r\n}\r\nfoo(a)  // 2\r\nconsole.log(a.abc)   // 2\r\n```\r\n上面的代码很容易得出一个错误的结论，对象传值是按引用传递的。\r\n\r\n对象a的引用被传递到函数foo内部， 函数内部变量x指向全局变量a，从而实现了引用的传递，所以变量x和变量a读写的是同一个对象。\r\n\r\n如果是按引用传递那下面这个例子就懵比了：\r\n```\r\nlet a = {\r\n    abc: 1\r\n}\r\nfunction foo(x) {\r\n    console.log(x) // {abc: 1}\r\n    x = 2\r\n    console.log(x) // 2\r\n}\r\nfoo(a)\r\nconsole.log(a.abc) // 1\r\n```\r\n为什么会出现a、x在指向同一个对象后，对x赋值又没有改变原对象的值呢？\r\n\r\n因为这里对象传递给实参是按共享传递（call by sharing）的，根据引用类型变量复制的特点（上面描述过）：\r\n\r\nfoo 函数执行时， 形参 x 的值是传进去的对象 a 的内存地址引用，即在变量对象创建阶段x保存的是一个对象的堆内存地址。此时 a、x 都指向同一对象。 接着在函数的执行阶段，代码的第二行将原始数据类型 2 赋值给 x，导致 x 不再保存原先的堆内存地址转而保存一个原始值，再次访问 x 的时候是访问对 x 最后一次赋值的原始值。\r\n\r\n<strong>所以对 x 的赋值会改变上下文栈中标识符 x 保存的具体值</strong>\r\n\r\n```\r\nlet a = {\r\n    abc: 1\r\n}\r\nfunction foo(x) {\r\n    x.abc = 99\r\n    console.log(x) // {abc: 99}\r\n    x = 2\r\n    console.log(x) // 2\r\n}\r\nfoo(a)\r\nconsole.log(a) // {abc: 99}\r\n```\r\n在 foo 函数内部修改对象 x 的属性，会导致 x、a 指向的对象被修改，因为它们指向同一个堆地址。\r\n### 深浅拷贝\r\n\r\n上面说过引用类型变量拷贝的特点。但是实际业务中，有时需要将一个引用类型拷贝一份，并且两个对象的值还不会相互影响。\r\n\r\n这里存在两种情况：浅拷贝和深拷贝\r\n```\r\nlet object1 = {\r\n  a: 1,\r\n  obj: {\r\n    b: 'string'\r\n  }\r\n}\r\n```\r\n#### 浅拷贝\r\n\r\n浅拷贝也存在两种情况：\r\n- 直接拷贝对象，也就是拷贝引用，两个变量object1 和 object2 之间还是会相互影响。\r\n- 只是简单的拷贝对象的第一层属性，基本类型值不再相互影响，但是对其内部的引用类型值，拷贝的任然是是其引用，内部的引用类型值还是会相互影响。\r\n\r\n```\r\n// 最简单的浅拷贝\r\nlet object2 = object1;  // 两个对象指向一个引用地址，改一个另一个也会改变\r\n\r\nlet object2 = Object.assign({}, object1)\r\nobject1.a = 666\r\nobject1.obj.b = 'newString'\r\nconsole.log(object2.a)  // 666\r\nconsole.log(object2.obj.b)  // 'newString'\r\n```\r\n浅拷贝存在许多问题，需要我们注意：\r\n\r\n- 只能拷贝可枚举的属性。\r\n- 所生成的拷贝对象的原型与原对象的原型不同，拷贝对象只是 Object 的一个实例。\r\n- 原对象从它的原型继承的属性也会被拷贝到新对象中，就像是原对象的属性一样，无法区分。\r\n- 属性的描述符（descriptor）无法被复制，一个只读的属性在拷贝对象中可能会是可写的。\r\n- 如果属性是对象的话，原对象的属性会与拷贝对象的属性会指向一个对象，会彼此影响。\r\n\r\n```\r\nfunction Parent() {\r\n\tthis.name = 'parent'\r\n\tthis.a = 1\r\n}\r\n\r\nfunction Child() {\r\n\tthis.name = 'child'\r\n\tthis.b = 2\r\n}\r\n\r\nChild.prototype = new Parent()\r\n\r\nlet child1 = new Child()\r\nconsole.log(child1.a,child1.name); // 1 \"child\"\r\n\r\nconsole.log(Parent.prototype); \r\nconsole.log(Child.prototype); \r\n\r\nObject.defineProperty(child1, 'name', {writable: false, value: 'ARRON'})\r\n// 更改child1的描述符writable为false\r\nlet child2 = Object.assign({}, child1)\r\n\r\nconsole.log(Object.getOwnPropertyDescriptor(child2, 'name'));\r\n// Object{value: \"ARRON\", writable: true, enumerable: true, configurable: true}\r\n// 这里描述符的可赋值writable已经变成true\r\n\r\nchild1.name = 'newName'; // 严格模式下报错，普通模式下无效\r\nchild2.name = 'newName'; // 可以赋值\r\nconsole.log( child1.name ); //  ARRON\r\nconsole.log( child2.name ); // newName\r\n\r\n// 查看 child1 和 child2 的原型，我们也会发现它们的原型也是不同的\r\nconsole.log(child1.__proto__);  // Parent\r\nconsole.log(child2.__proto__);  // Object\r\n```\r\n#### 深拷贝\r\n\r\n深拷贝就是将对象的属性递归的拷贝到一个新的对象上，两个对象有不同的地址，不同的引用，也包括对象里的对象属性（如 object1 中的 obj 属性），两个变量之间完全独立。\r\n\r\n\r\n#### 一些常用的深浅拷贝方法\r\n\r\n##### 对象浅拷贝\r\n1. Object.assign()\r\n  \r\n```\r\nvar object2 = Object.assign({}, object1);\r\n```\r\n\r\n2. Object.getOwnPropertyNames 拷贝不可枚举的属性\r\n\r\nObject.getOwnPropertyNames() 返回由对象属性组成的一个数组，包括不可枚举的属性（除了使用 Symbol 的属性）。\r\n\r\n```\r\nfunction shallowCopyOwnProperties( source )  \r\n{\r\n    var target = {} ;\r\n    var keys = Object.getOwnPropertyNames( original ) ;\r\n    for ( var i = 0 ; i < keys.length ; i ++ ) {\r\n        target[ keys[ i ] ] = source[ keys[ i ] ] ;\r\n    }\r\n    return target ;\r\n}\r\n```\r\n\r\n3. Object.getPrototypeOf 和 Object.getOwnPropertyDescriptor 拷贝原型与描述符\r\n\r\n```\r\nfunction shallowCopy( source ) {\r\n    // 用 source 的原型创建一个对象\r\n    var target = Object.create( Object.getPrototypeOf( source )) ;\r\n    // 获取对象的所有属性\r\n    var keys = Object.getOwnPropertyNames( source ) ;\r\n    // 循环拷贝对象的所有属性\r\n    for ( var i = 0 ; i < keys.length ; i ++ ) {\r\n        // 用原属性的描述符创建新的属性\r\n        Object.defineProperty( target , keys[ i ] , Object.getOwnPropertyDescriptor( source , keys[ i ])) ;\r\n    }\r\n    return target ;\r\n}\r\n```\r\n\r\n##### 数组浅拷贝\r\n1. 直接复制或者遍历\r\n\r\n```\r\nvar array = [1, 'string', {a: 1,b: 2, obj: {c: 3}}];\r\n// 直接复制\r\nvar array1 = array;\r\n// 遍历直接复制\r\nvar array2 = [];\r\nfor(var key in array) {\r\n  array2[key] = array[key];\r\n}\r\n// 改变原数组元素\r\narray[1] = 'newString';\r\narray[2].c = 4;\r\n\r\nconsole.log(array1[1]); // newString\r\nconsole.log(array1[2].c); // 4\r\nconsole.log(array2[1]); // string\r\nconsole.log(array2[2].c); // 4\r\n```\r\n\r\n2. slice 和 concat \r\n   \r\n```\r\nvar array = [1, 'string', {a: 1,b: 2, obj: {c: 3}}];\r\n// slice()\r\nvar array1 = array.slice();\r\n// concat()\r\nvar array2 = array.concat();\r\n// 改变原数组元素\r\narray[1] = 'newString';\r\narray[2].c = 4;\r\n\r\nconsole.log(array1[1]); // string\r\nconsole.log(array1[2].c); // 4\r\nconsole.log(array2[1]); // string\r\nconsole.log(array2[2].c); // 4\r\n```\r\n\r\n##### 数组、对象的深拷贝\r\n1.  JSON.stringify 和 JSON.parse\r\n\r\n```\r\nvar obj = { a: 1, b: { c: 2 }};\r\n// 深拷贝\r\nvar newObj = JSON.parse(JSON.stringify(obj));\r\n// 改变原对象的属性\r\nobj.b.c = 20;\r\n\r\nconsole.log(obj); // { a: 1, b: { c: 20 } }\r\nconsole.log(newObj); // { a: 1, b: { c: 2 } }\r\n```\r\n\r\n优点是方便简洁，可以处理大多数业务需求。\r\n\r\n缺点是属性里有function、undefined和symbol的话会被忽略。并且如果值有循环引用对象的话会报错。\r\n2. MessageChannel\r\n如果你所需拷贝的对象含有内置类型并且不包含函数，可以用MessageChannel\r\n\r\n```\r\nfunction structuralClone(obj) {\r\n  return new Promise(resolve => {\r\n    const {port1, port2} = new MessageChannel();\r\n    port2.onmessage = ev => resolve(ev.data);\r\n    port1.postMessage(obj);\r\n  });\r\n}\r\n\r\nvar obj = {a: 1, b: {\r\n    c: b\r\n}}\r\n// 注意该方法是异步的\r\n// 可以处理 undefined 和循环引用对象\r\n(async () => {\r\n  const clone = await structuralClone(obj)\r\n})()\r\n```\r\n\r\n3. 其他\r\n\r\n手写或者用[ lodash 的深拷贝函数](https://lodash.com/docs##cloneDeep)\r\n### typeOf和instanceof\r\ntypeof可以判断除了null的所有原始类型\r\n\r\n```\r\ntypeof 1 // 'number'\r\ntypeof '1' // 'string'\r\ntypeof undefined // 'undefined'\r\ntypeof true // 'boolean'\r\ntypeof Symbol() // 'symbol'\r\n```\r\n\r\n但是不能判断对象，除了函数都会显示object\r\n\r\n```\r\ntypeof [] // 'object'\r\ntypeof {} // 'object'\r\ntypeof console.log // 'function'\r\n```\r\n\r\ninstanceof 内部是通过原型链来判断的\r\n\r\n```\r\nconst Person = function() {}\r\nconst p1 = new Person()\r\np1 instanceof Person // true\r\n\r\nvar str = 'hello world'\r\nstr instanceof String // false\r\n// 没有.运算符并不会做装箱转换\r\n\r\nvar str1 = new String('hello world')\r\nstr1 instanceof String // true\r\n```\r\n\r\n在上篇文章《基本类型》里说过，\r\n\r\n> 在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。\r\n\r\n> instanceof 的判定如果在两个环境下可能会出错。比如网页内嵌 iframe。\r\n\r\n而且 instanceof 的行为是可以自定义修改的。\r\n\r\n```\r\nclass PrimitiveString {\r\n  static [Symbol.hasInstance](x) {\r\n    return typeof x === 'string'\r\n  }\r\n}\r\nconsole.log('hello world' instanceof PrimitiveString) // true\r\n```\r\n\r\n参考链接\r\n\r\n[InterviewMap](https://yuchengkai.cn/docs/frontend/#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B)\r\n\r\n[javascript参数传值](https://segmentfault.com/a/1190000015105086)\r\n\r\n[深入理解 JavaScript 对象和数组拷贝](https://juejin.im/post/5a00226b5188255695390a74#heading-8)\r\n"},LYLl:function(r,n){r.exports='###### ARRON 2019 年 2 月 7 日\r\n\r\nJS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。\r\n\r\n## 基本类型\r\n\r\n基本类型有六种： null，undefined，boolean，number，string，symbol\r\n\r\n首先我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。\r\n\r\nNumber、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。\r\n\r\nSymbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。\r\n\r\n原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString() 会抛出错误\r\n\r\n但为什么 \'1\'.toString() 是可以使用的。\r\n\r\n其实是 . 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。在该临时对象调用函数返回函数操作结果后，将该对象丢弃。\r\n\r\n### 装箱转换\r\n\r\n每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。\r\n\r\n前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。\r\n\r\n```\r\n    var symbolObject = (function(){ return this; }).call(Symbol("a"));\r\n\r\n    console.log(typeof symbolObject); // object\r\n    console.log(symbolObject instanceof Symbol); // true\r\n    console.log(symbolObject.constructor   Symbol); // true\r\n```\r\n\r\n使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。\r\n\r\n```\r\n    var symbolObject = Object((Symbol("a"));\r\n\r\n    console.log(typeof symbolObject); // object\r\n    console.log(symbolObject instanceof Symbol); // true\r\n    console.log(symbolObject.constructor   Symbol); // true\r\n\r\n```\r\n\r\n每一个装箱对象 console.dir 的时候，会发现有个 [[PrimitiveValue]] 标记，他会显示该对象内部指向的原始值。\r\n\r\n每一类对象（包括装箱对象）皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：\r\n\r\n```\r\n    var symbolObject = Object((Symbol("a"));\r\n\r\n    console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]\r\n```\r\n\r\n在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。\r\n\r\ninstanceof 的判定如果在两个环境下可能会出错。比如网页内嵌 iframe。\r\n\r\n但需要注意的是，call 本身会产生装箱操作，所以判断类型的时候需要配合 typeof 来区分基本类型还是对象类型。\r\n\r\n### 拆箱转换\r\n\r\n在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。\r\n\r\n```\r\n[Symbol.toPrimitive](hint)\r\n```\r\n\r\n如果 hint 是 "string" 或 "default"，[@@toPrimitive]() 将会调用 toString。如果 toString 属性不存在，则调用 valueOf。如果 valueOf 也不存在，则抛出一个 TypeError。\r\n\r\n如果 hint 是 "number"，[@@toPrimitive]() 会首先尝试 valueOf，若失败再尝试 toString。\r\n\r\nnumber\r\n\r\n```\r\n    var o = {\r\n        valueOf : () => {console.log("valueOf"); return {}},\r\n        toString : () => {console.log("toString"); return {}}\r\n    }\r\n\r\n    o * 2\r\n    // valueOf\r\n    // toString\r\n    // TypeError\r\n```\r\n\r\nstring\r\n\r\n```\r\n    var o = {\r\n        valueOf : () => {console.log("valueOf"); return {}},\r\n        toString : () => {console.log("toString"); return {}}\r\n    }\r\n\r\n    o + ""\r\n    // toString\r\n    // valueOf\r\n    // TypeError\r\n```\r\n\r\n当在希望是字符串操作，也即发生对象到字符串的转换时，传入内部函数 ToPrimitive 的参数值即为 string，当在希望是数值操作，传入内部函数 ToPrimitive 的参数值即为 number，当在一些不确定需要将对象转换成什么基础类型的场景下，传入内部函数 ToPrimitive 的参数值即为 default：\r\n\r\n```\r\n\tconst b = {\r\n\t\t\t[Symbol.toPrimitive] (hint) {\r\n\t\t\t\t\tconsole.log(`hint: ${hint}`);\r\n\t\t\t\t\treturn {};\r\n\t\t\t},\r\n\t\t\ttoString () {\r\n\t\t\t\t\tconsole.log(\'toString\');\r\n\t\t\t\t\treturn 1;\r\n\t\t\t},\r\n\t\t\tvalueOf () {\r\n\t\t\t\t\tconsole.log(\'valueOf\');\r\n\t\t\t\t\treturn 2;\r\n\t\t\t}\r\n\t};\r\n\r\n\talert(b); // hint: string\r\n\tb + \'\'; // hint: default\r\n\tb + 500; // hint: default\r\n\t+b; // hint: number\r\n\tb * 1; // hint: number\r\n```\r\n\r\n在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。\r\n\r\n```\r\n    var o = {\r\n        valueOf : () => {console.log("valueOf"); return {}},\r\n        toString : () => {console.log("toString"); return {}}\r\n    }\r\n\r\n    o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}\r\n\r\n\r\n    console.log(o + "")\r\n    // toPrimitive\r\n    // hello\r\n```\r\n\r\n### null 和 undefined\r\n\r\nnull 代表赋值了，但内容为空，undefined 表示未定义。\r\n\r\n另外对于 null 来说。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\r\n\r\n一般建议用 void 0 代替 undefined ，因为在 ES5 之前 undefined 是一个变量，而并非是一个关键字，为了避免无意中被修改，建议用 void 0 代替 undefined\r\n\r\n```\r\n    let a\r\n    // 我们也可以这样判断 undefined\r\n    a  = undefined\r\n    // 但是 undefined 不是保留字，能够在低版本浏览器被赋值\r\n    let undefined = 1\r\n    // 这样判断就会出错\r\n    // 所以可以用下面的方式来判断，并且代码量更少\r\n    // 因为 void 后面随便跟上一个组成表达式\r\n    // 返回就是 undefined\r\n    a  = void 0\r\n```\r\n\r\n### Boolean\r\n\r\n```\r\n    console.log(true  = new Boolean(true));  // false\r\n\r\n```\r\n\r\n因为 true 是基本类型，new Boolean(true)是一个对象\r\n\r\n### String\r\n\r\nJavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无论你在 string 类型上调用何种方法，都不会对值有改变。\r\n\r\nString 有最大长度是 2^53 - 1，但是这个最大长度并不是你理解的字符数，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。\r\n\r\n### Number\r\n\r\nJavaScript 中的 Number 类型有 (2^64 - 2^53+3) 个值。JavaScript 采用 IEEE 754 双精度版本(64 位)。\r\n\r\n> 指数为 2^e - 1 且尾数的小数部分全 0，这个数字是 ±∞。（符号位决定正负）\r\n\r\n> 指数为 2^e - 1 且尾数的小数部分非 0，这个数字是 NaN。\r\n\r\n其中 NaN，占用了 9007199254740990 位，即（2^53-2）；±∞ 占用两位。但是表示了三个直观的量。\r\n\r\nJavaScript 中的数字是 64-bits 的双精度，所以加减一下，一共有(2^64 - 2^53 + 3)个值。\r\n\r\n64 位双精度在计算机中存储占用 8 字节，64 位，有效位数为 16 位。其中符号位，指数位和尾数部分分别为 1, 11, 52。取值范围取决于指数位，计算精度取决于尾数位（小数）。\r\n\r\n小数位是 52 位（二进制），换算为十进制则只能百分百能保证 15 位。超过该精度（二进制 52 位，十进制 15 位）的小数运算将会被截取，造成精度损失和计算结果的不准确。\r\n\r\n```\r\n\tconsole.log( 0.000000000000001 <= Number.EPSILON ); // false\r\n\tconsole.log( 0.0000000000000001 <= Number.EPSILON ); // true\r\n\r\n```\r\n\r\n所以 JavaScript 提供的最小精度值 Number.EPSILON 为 2.220446049250313e-16 也就是\r\n小于 16 位小数(10 进制)。\r\n\r\n```\r\n\tconsole.log( 2.220446049250313e-16.toString(2) );\r\n\t// 0.0000000000000000000000000000000000000000000000000001\r\n\t// 52位小数(2进制)\r\n```\r\n\r\n##### 为什么 0.1 + 0.2 != 0.3\r\n\r\n计算机计算都是用二进制的。\r\n\r\n问：要把小数装入计算机，总共分几步？你猜对了，3 步。\r\n\r\n- 第一步：转换成二进制。\r\n- 第二步：用二进制科学计算法表示。\r\n- 第三步：表示成 IEEE 754 形式。\r\n\r\n  0.1 二进制计算过程\r\n\r\n```\r\n\t0.1*2=0.2========取出整数部分0\r\n\t0.2*2=0.4========取出整数部分0\r\n\t0.4*2=0.8========取出整数部分0\r\n\t0.8*2=1.6========取出整数部分1\r\n\t0.6*2=1.2========取出整数部分1　\r\n\t0.2*2=0.4========取出整数部分0\r\n\t0.4*2=0.8========取出整数部分0\r\n\t0.8*2=1.6========取出整数部分1\r\n\t0.6*2=1.2========取出整数部分1\r\n\t……\r\n```\r\n\r\n得到一个无限循环的二进制小数 0.000110011…\r\n\r\n用科学计数法表示\r\n\r\n0.000110011(0011) == 1.100110011(0011)\\*2^-4 // (0011) 表示循环\r\n\r\n> 任何一个 r 进制数 N 都可以写成（N）r=(+/-)S\\*r(+/-e)这种科学计数法\r\n\r\n> 其中 N 表示需要表示的数，r 表示进制，S 表示尾数，N 的有效位数字，e 表示阶码，代表小数点的位置\r\n\r\n表示成 IEEE 754 形式\r\n\r\n1. 正数 固符号位为 0\r\n2. 尾数 由于由于第一位使用是 1，固取(首位 1 干掉了) .100110011(0011)\r\n3. 指数 -4 + 1023(偏移量), 1019 转换为二进制就是 01111111011\r\n\r\n组合在一起就是 0-01111111011-100110011(0011)\r\n\r\n因为 IEEE 754 64 位只能存储 52 位尾数，剩下的需要舍入。\r\n\r\n因此 0.1 实际存储时的位模式是 0-01111111011-1001100110011001100110011001100110011001100110011010；\r\n\r\n0.2 同理得到 0-01111111100-1001100110011001100110011001100110011001100110011010；\r\n\r\n相加得到 0-01111111101-0011001100110011001100110011001100110011001100110100;转换为十进制即为 0.30000000000000004。\r\n\r\n> 单精度 32 位的 偏移量是 Math.pow(2,8)/2 -1 == 127 ，双精度 64 位的偏移量是 Math.pow(2,11)/2 -1 == 1023\r\n\r\n> 因为所有数的二进制科学计数都可以写成 1.xxxx，所以是固定的，取消默认 1，这样可以多出一位存储空间。\r\n\r\n##### 其它\r\n\r\n- 指数域不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数的计算值减去 127（或 1023），得到真实值，再将尾数前加上第一位的 1。\r\n- 指数域全为 0。这时，浮点数的指数等于 1-127（或者 1-1023），尾数不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。\r\n- 指数域全为 1。这时，如果尾数全为 0，表示 ± 无穷大（正负取决于符号位 s）；如果尾数不全为 0，表示这个数不是一个数（NaN）。\r\n\r\n### symbol\r\n\r\n```\r\n\tvar o = new Object\r\n\r\n\to[Symbol.iterator] = function() {\r\n\t\tvar v = 0\r\n\t\treturn {\r\n\t\t\tnext: function() {\r\n\t\t\t\treturn { value: v++, done: v > 10 }\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfor(var v of o)\r\n\t\tconsole.log(v); // 0 1 2 3 ... 9\r\n```\r\n\r\n代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。\r\n\r\n这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。\r\n\r\n这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。\r\n\r\n参考链接\r\n\r\n[numberInJavaScript](http://www.yangshengdonghome.com/2016/06/19/numberInJavaScript/)\r\n\r\n[重学前端](https://time.geekbang.org/column/154)'},NHnr:function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});e("cwe7"),e("+BTi");var t=e("2X9z"),a=e.n(t),o=(e("Yq4J"),e("qubY")),l=e.n(o),s=(e("GXEp"),e("mtrD")),i=e.n(s),c=e("7+uW"),u={render:function(){var r=this.$createElement,n=this._self._c||r;return n("div",{attrs:{id:"app"}},[n("h2",[this._v("用一定的词法和语法,去表达一定语义,最终操作运行时")]),this._v(" "),n("router-view")],1)},staticRenderFns:[]};var m=e("VU/8")({name:"App"},u,!1,function(r){e("pOEp")},null,null).exports,b=e("/ocq"),g=e("EFqf"),f=e.n(g),p={data:function(){return{title:"",dialogVisible:!1,input:"",data:{name:"前端知识构架",children:[{name:"javascript",children:[{name:"运行时",children:[{name:"数据结构",children:[{name:"类型",children:[{name:"基本类型",file:"type1"},{name:"对象",file:"type2"},{name:"类型转换",file:"type3"}]},{name:"实例",children:[{name:"应用和机制"}]}]},{name:"执行过程（）",children:[{name:"事件循环"},{name:"做任务的执行"},{name:"函数的执行"},{name:"语句级的执行"}]}]},{name:"文法",children:[{name:"词法"},{name:"语法"}]},{name:"语义",children:[{name:"语义化标签",file:"semantic1"}]}]},{name:"HTML&CSS",children:[{name:"HTML",children:[{name:"元素",children:[{name:"文档元信息"},{name:"语义相关内容"},{name:"链接"},{name:"替换型元素"},{name:"表单"},{name:"表格"},{name:"总集"}]},{name:"语言",children:[{name:"实体"},{name:"命名空间"}]},{name:"补充标准"}]},{name:"CSS",children:[{name:"语言",children:[{name:"@rule"},{name:"选择器"},{name:"单位"}]},{name:"功能",children:[{name:"布局",children:[{name:"正常流"},{name:"弹性布局"}]},{name:"绘制",children:[{name:"颜色和形状"},{name:"文字相关"}]},{name:"交互",children:[{name:"动画"},{name:"其他交互"}]}]}]}]},{name:"浏览器的实现原理和API",children:[{name:"实现原理",children:[{name:"解析"},{name:"构建DOM树"},{name:"计算CSS"},{name:"渲染、合成和绘制"}]},{name:"API",children:[{name:"DOM"},{name:"CSSOM"},{name:"事件"},{name:"API总集合"}]}]},{name:"前端工程实践",children:[{name:"性能"},{name:"工具链"},{name:"持续集成"},{name:"搭建系统"},{name:"架构与基础库"}]}]}}},mounted:function(){this.Chart(),this.mark()},computed:{compiledMarkdown:function(){return f()(this.input,{sanitize:!1})}},methods:{mark:function(){var r=new f.a.Renderer;f.a.setOptions({renderer:r,gfm:!0,tables:!0,breaks:!1,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!1,highlight:function(r,n){return hljs.highlightAuto(r).value}})},Chart:function(){var r=this.$echarts.init(document.getElementById("main")),n=this;r.on("click",function(r){r.data.children||(r.data.file?(n.title=r.name,n.input=e("geK+")("./"+r.data.file+".md"),n.dialogVisible=!0):n.$message({message:"暂时没有相关文章",type:"warning"}))});var t={tooltip:{trigger:"item",triggerOn:"mousemove"},series:[{type:"tree",data:[this.data],top:"1%",left:"10%",bottom:"1%",right:"20%",symbolSize:10,label:{normal:{position:"left",verticalAlign:"middle",align:"right",fontSize:16}},leaves:{label:{normal:{position:"right",verticalAlign:"middle",align:"left"}}},initialTreeDepth:10,expandAndCollapse:!0,animationDuration:550,animationDurationUpdate:750}]};r.hideLoading(),r.setOption(t)}}},d={render:function(){var r=this,n=r.$createElement,e=r._self._c||n;return e("div",[e("div",{staticStyle:{height:"800px"},attrs:{id:"main"}}),r._v(" "),e("el-dialog",{attrs:{title:r.title,visible:r.dialogVisible,width:"70%",center:""},on:{"update:visible":function(n){r.dialogVisible=n}}},[e("div",{domProps:{innerHTML:r._s(r.compiledMarkdown)}}),r._v(" "),e("span",{staticClass:"dialog-footer",attrs:{slot:"footer"},slot:"footer"},[e("el-button",{on:{click:function(n){r.dialogVisible=!1}}},[r._v("取 消")]),r._v(" "),e("el-button",{attrs:{type:"primary"},on:{click:function(n){r.dialogVisible=!1}}},[r._v("确 定")])],1)])],1)},staticRenderFns:[]};var h=e("VU/8")(p,d,!1,function(r){e("lAnh")},null,null).exports;c.default.use(b.a);var v=new b.a({routes:[{path:"/",name:"home",component:h}]}),y=e("Pg0u"),S=e.n(y);e("tvR6");c.default.prototype.$echarts=S.a,c.default.use(i.a),c.default.use(l.a),c.default.prototype.$message=a.a,c.default.config.productionTip=!1,new c.default({el:"#app",router:v,components:{App:m},template:"<App/>"})},Pg0u:function(r,n){r.exports=echarts},Yq4J:function(r,n){},avjR:function(r,n){r.exports="刚刚无意之中在网上看到 `web worker` 这个词，瞬间跌入了回忆的深渊，什么 `serviceWorker`、`walking dead`、亲爱的长者 乱七八糟一齐涌了出来，就是没有 `web worker`，最后颓废的发现，原来关于 `worker` 相关的东西自己已经忘干净了。\r\n\r\n不过隐约记得这东西用起来不很复杂，于是果断上 MDN 看看文档，但是又无意中看到 `MessageChannel` 这个词，很明显幼小的心灵又被一个陌生的词汇狠狠的鞭笞了一下。忍不住点进去看了一下关于 `MessageChannel` 的资料，发现这行代码 ([来源](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel/MessageChannel)):\r\n\r\n```js\r\notherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\r\n```\r\n\r\n蛤？原来 `postMessage` 方法可以接收第 `3` 个参数？那请问第三个参数是什么意思？文章里说的 `MessgaePort` 对象又是什么？想到这么多问题自己还完全摸不着边，而且问题之间环环相扣，于是仔细深究了一番，下面是一些笔记。\r\n\r\n#### 什么是 MessageChannel ?\r\n首先，`MessageChannel` 是一个构造函数，创建一对相互连接的 `MessagePort` 对象。\r\n\r\n```js\r\nvar mc=new MessageChannel;\r\nmc.port1.onmessage=function(e){console.log(\"port1：\"+e.data);};\r\nmc.port2.onmessage=function(e){console.log(\"port2：\"+e.data);};\r\nmc.port1.postMessage(\"1\"); //会在port2的message事件收到\r\nmc.port2.postMessage(\"2\"); //会在port1的message事件收到\r\n```\r\n\r\n(这段代码的[来源](https://www.web-tinker.com/article/20320.html))\r\n\r\n上面说的一对相互连接的 `MessagePort` 对象分别是 `mc.port1` 和 `mc.port2`，他们可以相互给对方发送消息，并且处理接收到的消息。这就是 `MessageChannel` 最基本的用法，很简单，但是看起来很无用。\r\n\r\n#### postMessage 很好用\r\n我们知道 `postMessage` 可以用于 `worker` 和跨文档消息传递机制，用起来也很简单，只要记住 `postMessage` 是”自己给自己发消息“，我们以后者为例：\r\n\r\n```js\r\n// index.html\r\nvar iframe = document.querySelector('iframe')\r\niframe.onload = () => {\r\n  let w = iframe.contentWindow\r\n\r\n  w.onmessage = (e) => {\r\n    console.log(e.data)\r\n  }\r\n  w.postMessage('initialize', '*')\r\n}\r\n\r\n// iframe.html\r\nonmessage = (e) => {\r\n  console.log(e.data)\r\n  window.postMessage(`Received message: ${e.data}`)\r\n}\r\n```\r\n\r\n上面这段代码逻辑非常简单，`iframe` 自己给自己发消息并处理接收到的消息，但是可能不好理解的就是所谓的 “自己给自己发消息”。在我们正常的认知中，发消息通常都是一方发给另外一方，哪有自己给自己发消息的 (自言自语除外)。而且因为自发消息的特性，在不同的上下文中 (不同的页面或者 worker 与 main thread 间)，`postMessage` 和 `onmessage` 在写法上看起来又不像是 ”自己给自己发“：在 `index.html` 中写法是 `iframe.contentWindow.postMessage`，在 `iframe.html` 中写法又是 `window.postMessage`。总之，如果不习惯的话从文字上看起来会觉得这种写法有些别扭，不过好在我们还有另一种写法。\r\n\r\n#### MessageChannel 让通信变得更简单\r\n上面说到 `MessageChannel` 构造函数会创建一对相互关联的 `MessagePort` 对象，怎么理解 `MessagePort` 对象呢？可以把一个 `MessagePort` 对象当成消息传递的管道，我们可以通过这两个对象来进行消息的传递，想象一下现实生活中的两个人通过手机打电话，一个 `MessagePort` 对象就是一个手机。\r\n\r\n`MessageChannel` 其实就更好理解了，不再是自己给自己发消息，而是一方发给另一方，也即是 `mc.port1` 和 `mc.port2` 相互传递处理消息。\r\n\r\n但是怎么利用 `MessageChannel` 来让我们现有的消息传递机制更加简单清晰呢？答案正是我们上面说的 `window.postMessage` 方法的第三个参数 (`MessagePort.postMessage` 里是第二个参数)。\r\n\r\n这个参数是可选的，而且如果有的话必须是 `Array/ArrayLike`，表示 “跟随信息一起传送的可转让对象的序列”，意思就是把这些可转让对象的所有权转让给目的上下文 **(注意只有 `MessagePort` 和 `ArrayBuffer` 对象可以被转移)**。\r\n\r\n什么意思呢？看文章里的第一行代码：\r\n\r\n```js\r\notherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);\r\n```\r\n\r\n这里 `channel.port2` 就被转移到 `otherWindow` 上下文中去了，也就是现在 `channel.port2` 能够被 `otherWindow` 上下文访问到了。不过这样有什么用呢？我们不还是用了 `postMessage` 方法吗？\r\n\r\n其实很好理解，想像一下，现在你跟你的一个小伙伴分隔两地，通信是通过邮政寄信的方式，很不方便，但是某天你突然得到两个电话，然后通过邮政发给你的小伙伴一个，这样等小伙伴收到电话你们就能愉快的打电话了。翻译过来就是：通过 `postMessage` 把其中一个 `MessagePort` 对象传递给需要通信的一方，然后双方就可以通过 `MessagePort` 对象相互通信。\r\n\r\n好了就说这么多，下面直接上完整的代码，很好理解：\r\n\r\n```\r\n// index.html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <title></title>\r\n</head>\r\n<body>\r\n    <iframe src=\"iframe.html\" frameborder=\"0\"></iframe>\r\n    <script>\r\n        var channel = new MessageChannel\r\n        var port = channel.port1\r\n\r\n        var iframe = document.querySelector('iframe')\r\n        iframe.onload = () => {\r\n          iframe.contentWindow.postMessage('initialize', '*', [channel.port2])\r\n        }\r\n\r\n        port.addEventListener('message', (e) => {\r\n          console.log(e.data, e)\r\n        }, false)\r\n\r\n        // 因为我们用的是 addEventListener 而不是 onmessage,\r\n        // 所以需要调用 port.start 方法\r\n        // 见: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\r\n        port.start()        \r\n    <\/script>\r\n</body>\r\n</html>\r\n\r\n// iframe.html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <title></title>\r\n</head>\r\n<body>\r\n    <script>\r\n      onmessage = (e) => {\r\n        // index.html 传递过来的 MessagePort 对象\r\n        // 通过 e.ports[0] 获取\r\n        var port = e.ports[0]\r\n\r\n        // 现在可以愉快的通过 port\r\n        // 进行消息传递\r\n        port.onmessage = (e) => {\r\n          console.log('from iframe: ' + e.data)\r\n        }\r\n        port.postMessage('sad')       \r\n      }\r\n    <\/script>   \r\n</body>\r\n</html>\r\n```\r\n\r\n#### 总结\r\n`MessageChannel` 是基本的双向信息传输管道，可以把它想象成 `window.postMessage`/`window.onmessage` 的另一种更加清晰的替代方案。最后要说的一点就是，sharedWorker 默认使用了 `MessagePort` 进行消息传递，有兴趣的同学可以自行探索。"},cwe7:function(r,n){},"geK+":function(r,n,e){var t={"./annualPlan.md":"38D4","./semantic1.md":"4DoG","./type1.md":"LYLl","./type2.md":"Gotm","./type3.md":"gu2x","./typex.md":"avjR"};function a(r){return e(o(r))}function o(r){var n=t[r];if(!(n+1))throw new Error("Cannot find module '"+r+"'.");return n}a.keys=function(){return Object.keys(t)},a.resolve=o,r.exports=a,a.id="geK+"},gu2x:function(r,n){r.exports="###### ARRON 2019 年 2 月 12 日\r\n\r\nJS里的类型转换有四种情况,原始类型转Object的一般不用手动处理,默认的装箱转换会自动处理.\r\n\r\n- 转换为布尔值\r\n- 转换为数字\r\n- 转换为字符串\r\n- 转换为对象\r\n\r\n\r\n原始值 | Boolean | Number | String | Object\r\n---|---|---|---|---\r\nNull | false | 0 | \"null\"| TypeError\r\nUndefined | false | NaN | \"undefined\"| TypeError\r\nBoolean(true) | - | 1 | \"true\" | 装箱转换\r\nBoolean(false) | - | 0 | \"false\" | 装箱转换\r\nNumber | 除了0/\\-0/NaN都为true| - | #NumberToString | 装箱转换\r\nString | \"\"为flase | #StringToNumber | -| 装箱转换\r\nSymbol | true | TypeError | TypeError | 装箱转换\r\nObject | true | 拆箱转换 | 拆箱转换 | -\r\n\r\n> 开箱转换,拆箱转换看上一篇< 基本类型 >\r\n> 关于null、undefined转换为Object，在权威指南中写的是TypeError，但这里其实用Object()来转换时，会返回一个空对象{}。但这个空对象是没有原始值 [[PrimitiveValue]] 的，只是一个空对象。\r\n\r\nObject拆箱转换补充\r\n\r\n原始值 | Boolean | Number | String \r\n---|---|---|---\r\n{}任意对象 | true | NaN | toString()\r\n[] | true | 0 | \"\"\r\n[8]单数字数组 | true | 9 | \"9\"\r\n[\"a\",4,true] | true | NaN | \"a,4,true\"\r\nfunction(){} | true | NaN | \"function(){}\"\r\n\r\n### NumberToString\r\n\r\n一般来说,Number都会转成相同表示方法的字符串。但是，当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示。实际上这个时候的Number也是用科学计数法表示的。\r\n\r\n\r\n```\r\nlet a = 1111111111111111111111111\r\nconsole.log(a);\r\n// 1.1111111111111111e+24\r\nconsole.log(a.toString());\r\n// '1.1111111111111111e+24'\r\n```\r\n\r\n### StringToNumber\r\n\r\n字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：\r\n\r\n```\r\nNumber(\"123\")     // 123\r\nNumber(\"\")        // 0\r\nNumber(\"0x11\")    // 17\r\nNumber(\"0b11\")    // 3\r\nNumber(\"0o11\")    // 9\r\nNumber(\"foo\")     // NaN\r\nNumber(\"100a\")    // NaN\r\n```\r\n此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：\r\n\r\n- 1e22\r\n- 1e-3\r\n\r\n需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。\r\n\r\n### parseInt、parseFloat\r\n```\r\nparseFloat(\"3.14\");  // 3.14\r\nparseFloat(\"314e-2\");  // 3.14\r\nparseFloat(\"0.0314E+2\");  // 3.14\r\nparseFloat(\"3.14more non-digit characters\");  // 3.14\r\nparseFloat(\"FF2\");  // NaN\r\n```\r\n\r\n在任何环境下，都建议传入 parseInt 的第二个参数。\r\n\r\n```\r\nparseInt(4.7 * 1e22, 10); // 非常大的数值变成 4\r\nparseInt(0.00000000000434, 10); // 非常小的数值变成 4\r\n\r\nparseInt(\"Hello\", 8); // NaN 根本就不是数值\r\nparseInt(\"546\", 2);   //  NaN  除了“0、1”外，其它数字都不是有效二进制数字\r\n```\r\n\r\n一些数中可能包含e字符（例如6.022e23），使用parseInt去截取包含e字符数值部分会造成难以预料的结果。例如：\r\n```\r\nparseInt(\"6.022e23\", 10);        // 返回 6\r\nparseInt(6.022e2, 10);          // 返回 602\r\n```\r\n\r\n### 运算符\r\n\r\n#### 加法运算符\r\n- 运算中其中一方为字符串，那么就会把另一方也转换为字符串\r\n- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串\r\n\r\n```\r\n1 + '1' // '11'\r\ntrue + true // 2\r\n4 + [1,2,3] // \"41,2,3\"\r\n\r\n```\r\n加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。\r\n```\r\n'3' + 4 + 5 // \"345\"\r\n3 + 4 + '5' // \"75\"\r\nconsole.log('a' + - 'b')  // aNaN\r\n```\r\n\r\n对于除了加法的运算符（比如减法、除法和乘法）来说，都不会发生重载，只要其中一方是数字，那么另一方就会被转为数字\r\n```\r\n4 * '3' // 12\r\n4 * [] // 0\r\n4 * [1, 2] // NaN\r\n```\r\n\r\n#### 比较运算符\r\n\r\nJavaScript 一共提供了8个比较运算符。\r\n\r\n- \\> 大于运算符\r\n- < 小于运算符\r\n- <= 小于或等于运算符\r\n- \\>= 大于或等于运算符\r\n- == 相等运算符\r\n- === 严格相等运算符\r\n- != 不相等运算符\r\n- !== 严格不相等运算符\r\n\r\n这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。\r\n\r\n##### 非相等运算符\r\n如果两个运算子都是原始类型的值，则是先转成数值再比较。\r\n```\r\n5 > '4' // true\r\n// 等同于 5 > Number('4')\r\n// 即 5 > 4\r\n\r\ntrue > false // true\r\n// 等同于 Number(true) > Number(false)\r\n// 即 1 > 0\r\n\r\n2 > true // true\r\n// 等同于 2 > Number(true)\r\n// 即 2 > 1\r\n```\r\n任何值（包括NaN本身）与NaN比较，返回的都是false。\r\n```\r\n1 > NaN // false\r\n1 <= NaN // false\r\n'1' > NaN // false\r\n'1' <= NaN // false\r\nNaN > NaN // false\r\nNaN <= NaN // false\r\n```\r\n如果运算子是对象，会转为原始类型的值，再进行比较。\r\n```\r\nlet a = {\r\n  valueOf() {\r\n    return 0\r\n  },\r\n  toString() {\r\n    return '1'\r\n  }\r\n}\r\na > -1 // true\r\n```\r\n上面代码，重写valueOf和toString，拆箱转换，大于运算符hint为Number，先执行valueOf。如果没重写valueOf和toString，valueOf会拿到对象本身。\r\n\r\n对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，toString会拿到[Object Object]。\r\n\r\n如果toString方法返回的不是原始类型的值，结果就会报错。\r\n\r\n```\r\nlet a = {\r\n  valueOf() {\r\n    return {}\r\n  },\r\n  toString() {\r\n    return {}\r\n  }\r\n}\r\na > -1  // TypeError\r\n```\r\n'[Object Object]'转Number是NaN，NaN和任何比较都是false\r\n```\r\nlet a = {}\r\na > 1 // false\r\n```\r\n\r\n所以\r\n```\r\nlet a = {}\r\na + 1  // [object Object]1\r\n```\r\n##### 严格相等(\\=\\=\\=) 和 相等(==)\r\n\r\n严格相等\r\n\r\n原始类型，值和类型全部相同，返回true，否则返回false\r\n```\r\n1 === 0x1 // true\r\ntrue === \"true\" // false\r\nNaN === NaN  // false\r\n+0 === -0 // true\r\n```\r\n\r\n复合类型，两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。\r\n```\r\n{} === {} // false\r\n[] === [] // false\r\n(function () {} === function () {}) // false\r\n```\r\n如果两个变量引用同一个对象\r\n```\r\nvar v1 = {};\r\nvar v2 = v1;\r\nv1 === v2 // true\r\n```\r\n对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。\r\n```\r\nvar obj1 = {};\r\nvar obj2 = {};\r\n\r\nobj1 > obj2  // false\r\nobj1 < obj2  // false\r\nobj1 === obj2  // false\r\n```\r\nundefined和null与自身严格相等，所以\r\n```\r\nvar v1;\r\nvar v2;\r\nv1 === v2  // true\r\n```\r\n相等\r\n\r\n原始类型的值会转换成数值再进行比较。\r\n\r\n```\r\n1 == true // true\r\n// 等同于 1 === Number(true)\r\n\r\n0 == false // true\r\n// 等同于 0 === Number(false)\r\n\r\n2 == true // false\r\n// 等同于 2 === Number(true)\r\n\r\n2 == false // false\r\n// 等同于 2 === Number(false)\r\n\r\n'true' == true // false\r\n// 等同于 Number('true') === Number(true)\r\n// 等同于 NaN === 1\r\n\r\n'' == 0 // true\r\n// 等同于 Number('') === 0\r\n// 等同于 0 === 0\r\n\r\n'' == false  // true\r\n// 等同于 Number('') === Number(false)\r\n// 等同于 0 === 0\r\n\r\n'1' == true  // true\r\n// 等同于 Number('1') === Number(true)\r\n// 等同于 1 === 1\r\n\r\n'\\n  123  \\t' == 123 // true\r\n// 因为字符串转为数字时，省略前置和后置的空格\r\n```\r\n\r\n对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。\r\n\r\n```\r\n// 对象与数值比较时，对象转为数值\r\n[1] == 1 // true\r\n// 等同于 Number([1]) == 1\r\n\r\n// 对象与字符串比较时，对象转为字符串\r\n[1] == '1' // true\r\n// 等同于 String([1]) == '1'\r\n[1, 2] == '1,2' // true\r\n// 等同于 String([1, 2]) == '1,2'\r\n\r\n// 对象与布尔值比较时，两边都转为数值\r\n[1] == true // true\r\n// 等同于 Number([1]) == Number(true)\r\n[2] == true // false\r\n// 等同于 Number([2]) == Number(true)\r\n```\r\n\r\nundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。\r\n\r\n```\r\nfalse == null // false\r\nfalse == undefined // false\r\n\r\n0 == null // false\r\n0 == undefined // false\r\n\r\nundefined == null // true\r\n```\r\n\r\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果。\r\n```\r\n2 == true           // false\r\n2 == false          // false\r\n\r\nfalse == 'false'    // false\r\nfalse == '0'        // true\r\n\r\nfalse == undefined  // false\r\nfalse == null       // false\r\nnull == undefined   // true\r\n\r\n' \\t\\r\\n ' == 0     // true\r\n```\r\n因此建议不要使用相等运算符（\\=\\=），最好显式转换数据类型，使用严格相等运算符（\\=\\=\\=）。\r\n\r\n参考链接\r\n\r\n[《JavaScript 标准参考教程（alpha）》 by 阮一峰](http://javascript.ruanyifeng.com/)\r\n\r\n"},lAnh:function(r,n){},pOEp:function(r,n){},tvR6:function(r,n){}},["NHnr"]);
//# sourceMappingURL=app.68f13823cc4d3edccebf.js.map